{"meta":{"title":"Agenric's Blog","subtitle":"独立才会有思想","description":"世界在热闹什么...","author":"Agenric","url":"http://blog.agenric.cn","root":"/"},"pages":[{"title":"categories","date":"un66fin66","updated":"un11fin11","comments":false,"path":"categories/index.html","permalink":"http://blog.agenric.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"un66fin66","updated":"un11fin11","comments":false,"path":"tags/index.html","permalink":"http://blog.agenric.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mac使用小技巧","slug":"Mac-use-tips","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2020/06/01/Mac-use-tips/","link":"","permalink":"http://blog.agenric.cn/2020/06/01/Mac-use-tips/","excerpt":"","text":"保存一些小的tips Mac系统语言为英文的情况下，设置office语言为中文 123defaults write com.microsoft.Word AppleLanguages '(\"zh-cn\")'defaults write com.microsoft.Excel AppleLanguages '(\"zh-cn\")'defaults write com.microsoft.Powerpoint AppleLanguages '(\"zh-cn\")' Mac应用无法打开或文件损坏 1sudo spctl --master-disable VSCode 插件降级 找到你需要降级的插件的 [作者：author] 和 [名称：name] 修改这个 URL : https://[author].gallery.vsassets.io/_apis/public/gallery/publisher/[author]/extension/[name]/[version]/assetbyname/Microsoft.VisualStudio.Services.VSIXPackage 然后扔到浏览器下载 下载完成之后修改扩展名 .VSIXPackage 为 .vsix Terminal 执行 12$ code --install-extension Microsoft.VisualStudio.Services.vsixExtension 'Microsoft.VisualStudio.Services.vsix' was successfully installed! 然后打开 VSCode 你会发现，旧版本回来了。 对了，记得关闭 VSCode 插件自动更新。","categories":[{"name":"效率","slug":"效率","permalink":"http://blog.agenric.cn/categories/效率/"}],"tags":[]},{"title":"Travis CI 让你愉快的刷 LeetCode","slug":"Make-LeetCode-better-with-Travis-CI","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2019/04/20/Make-LeetCode-better-with-Travis-CI/","link":"","permalink":"http://blog.agenric.cn/2019/04/20/Make-LeetCode-better-with-Travis-CI/","excerpt":"","text":"对，感觉自己最近有点魔怔了。感觉跟 Travis CI 干上了。我前两天刚把 Hexo 的博客重新整理完，今天早起打开 Travis CI 发现我前两天做的一个 LeetCode 的项目构建失败，对，是因为在此之前我一直没有配置好。 事实上我大概半个月之前无意间在 github 上看到了 leetcode-cli 这个项目，当时好奇就玩了一下，其中 leetcode show 这个命令很有趣，show 命令可以让我们快速的预览某一道题的详细信息。 比如说我们查看一下第一题的详情，那就很简单 leetcode show 1 -g -l swift 同时指定使用 swift 语音来预览题目详情。 你会发现当前目录下多了一个 1.two-sum.swift 文件，诶，我就在想，如果我一直从1 show 到100那岂不是会有100个 swift 文件。既然已经把题目 down 到了本地我就不用每次都在线看了，然后我们打开 1.two-sum.swift，只有一个类下面的一个方法，我就在想时间久了之后我可能就忘了这个题到底是要解决什么问题了，所以必须要把题目的要求同时保存下来，当然这也不难，我们把命令行的输出直接写到一个临时文件里，然后把这个文件的内容添加到 1.two-sum.swift 中就好了。 然后，我有了一个大胆的想法…既然一道题可以这也搞，那所有的也都没有什么问题啊，所以就有了这篇文章，把所有的工作交给 CI，每天去 LeetCode 帮我同步一下最新的题库，然后帮我 push 到我指定的仓库，等我想刷的时候，就在本地 pull 一下，然后所有的题就回来了。这样岂不是美滋滋？虽然我也不知道我到猴年马月才能把这些东西看完…算了，我不想写了，代码都在 这里，就这样。","categories":[{"name":"效率","slug":"效率","permalink":"http://blog.agenric.cn/categories/效率/"}],"tags":[{"name":"Travis CI","slug":"Travis-CI","permalink":"http://blog.agenric.cn/tags/Travis-CI/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.agenric.cn/tags/LeetCode/"}]},{"title":"借助 Travis CI 使 Hexo 变得更好","slug":"Make-Hexo-better-with-Travis-CI","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2019/04/13/Make-Hexo-better-with-Travis-CI/","link":"","permalink":"http://blog.agenric.cn/2019/04/13/Make-Hexo-better-with-Travis-CI/","excerpt":"","text":"对，我懒得写博客，却喜欢折腾，这可能是病…OK，最近又换了电脑，每次换电脑都要迁移。 暂时进入回忆状态：-&gt;最开始玩博客我用的是 WordPress，后来觉得 Hexo 比较好玩，遂换成 Hexo，但是 Hexo 依赖 Node，这就导致一个问题，每次换电脑都需要重新配置一下环境，换成 Hexo 之后保守估计我已经迁移过最少三次了。不过今天，我动摇了。一个没有技术含量的操作如果需要重复三次以上那可能就是时候考虑让程序帮我们去重复这个操作了。 所以，有了这篇文章… 使用自动构建之前首先要了解手动构建的步骤既然要自动化，那么首先就必须得了解非自动化的流程，所以我们先来回顾一下 使用 Hexo 构建博客 的流程： 12345678910// 一个新的 Hexo 博客从创建到部署到 github 只需要简单几步$ npm install hexo-cli -g // 全局安装 Hexo$ hexo init blog // 以 blog 文件夹为根目录初始化一个 Hexo 的博客$ cd blog // 进入到博客根目录$ npm install // 安装 Hexo 的依赖$ hexo new [name].md // 创建一篇新的博文$ hexo server // 本地测试$ hexo generate // 生成网站静态文件$ hexo deploy // 部署网站到服务器 当然，以上流程只是非常简单的步骤，理论上如果要将 Hexo 部署到 github 还需要一个 hexo-deployer-git 插件，你可以在 blog 目录执行 npm install hexo-deployer-git --save 来安装它。更多关于 deploy 的信息可以来 这里 查看。 从上面流程我们可以看出来一篇新的博文就从 hexo new [name] 开始，执行完这个命令之后我们就会在 source 文件夹下看到 [name].md 这个文件。 这样的话也就是说，我们可以把除了 hexo new 这个操作放到本地之外其余所有的操作都可以借助 Travis CI 来完成。由此带来的结果就是我们本地其实只需要维护所有博文的 .md 文件集合即可。 同时我们还应该注意到 _config.yml 文件，这个文件的内容将表现出我们的博客呈现一种什么样的主题、博客的名称、一些个性化的设置等等，因为大概不会有人会使用所有默认的配置。 最后如果说你还有自已的的域名，那么还会有一个 CNAME 文件，这个文件其实也是在 source 文件夹当中，伴随着 hexo generate 生成静态网页源文件时会自动拷贝到public文件夹中的。 把可以转换成自动操作的步骤交给自动化服务去处理我们知道 Travis CI 是一个可以在线进行代码构建的持续集成服务，所以我们把这些步骤交给它去做。 在此之前我的 github 有两个仓库，一个是 agenric.github.io 用来存放静态网站的源文件，另一个是 backup-blog 用来跟我本地的博文源文件做同步。 但是现在我完全没必要这样做了，我完全可以在同一个仓库的两个分支保存这两份文件，因为 github 的 pages 服务只允许在 master 分支进行构建，所以我在 agenric.github.io 中创建一个新的 blog 分支，在这个分之下我维护了一个 source 文件夹和 _config.yml 、.travis.yml 两个文件。 _config.yml 事实上就是我之前旧的博客的样式文件，我需要在自动构建时使用该样式文件。.travis.yml 不用解释，用来描述 Travis CI 具体的构建步骤。 下面贴出我的 .travis.yml 文件来详细看一下流程： 1234567891011121314151617181920212223242526272829303132333435363738language: node_jsnode_js: - \"8.9.1\"branches:only: - blogcache: directories: - node_modulesbefore_install: - npm install npm@latest -g - npm update -g - cd ..install: - npm install hexo-cli -g - hexo init blog - cd blog - /bin/cp -rf ../agenric.github.io/package.json package.json - cat package.json - npm installscript: - /bin/cp -rf ../agenric.github.io/_config.yml _config.yml - rm -rf source/ - /bin/cp -rf ../agenric.github.io/source ./ - git clone https://github.com/Agenric/hexo-theme-next.git themes/next - sed -i'' \"/^ *repo/s~github\\.com~$&#123;GITHUB_TOKEN&#125;@github.com~\" _config.yml - hexo gafter_success: - git init - git config user.name \"Travis CI\" - git config user.email \"agenricwon@gmail.com\" - hexo d 我们指定构建的默认环境是 Node 8.9.1 版本，只在 blog 分支执行构建操作，同时为了加快构建速度，我们给 node_modules 文件夹添加缓存。 在安装 Hexo 之前，先将本地的 npm 以及 npm 默认包的版本到最新，然后我们覆盖默认的 package.json，package.json 指定了我所需要的所有插件以及版本要求。接着 install，结束之后你会发现所有的准备工作已经做完了。 安装完所需要的所有插件之后，在 script 阶段我会先把网站的配置文件和博文源文件拷贝并粘贴到 blog 的根目录。同时接着安装所需的主题之后，我们看到我需要设置 _config.yml 文件中 deploy 到的远程 repo 地址。然后执行构建操作。 最后在所有的操作结束之后，执行 deploy 操作。 至此，我在一台新设备上只需要 clone agenric.github.io 这个仓库的 blog 分支，在 source/_posts 文件夹中创建新的博文即可。","categories":[{"name":"效率","slug":"效率","permalink":"http://blog.agenric.cn/categories/效率/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.agenric.cn/tags/Hexo/"},{"name":"Travis CI","slug":"Travis-CI","permalink":"http://blog.agenric.cn/tags/Travis-CI/"}]},{"title":"可爱的 git stash 命令","slug":"Lovely-git-stash-command","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2018/01/30/Lovely-git-stash-command/","link":"","permalink":"http://blog.agenric.cn/2018/01/30/Lovely-git-stash-command/","excerpt":"","text":"记一次手残的经历 直击正文。 开发中可能经常会遇到正在开发的过程中，发现一些功能需要依附于你的同事或者小伙伴开发的一些功能才能往下继续。 所以，我们不想产生很多没有意义的commit，这个时候需要使用 git stash 命令。 比如说我刚刚，stash一下本地的更改，拉下来远端最新的代码，更新到我fork的仓库，pop出刚才stash的内容。 对，我手残的执行了一个git stash drop。就是因为iTerm有记忆功能😭。我差点以为自己要通宵了，不过幸好，git这么强大的工具，怎么可能会这么轻易的就让我们前功尽弃呢。 所以，如果你也不幸（手残）的不小心扔掉了本不该扔掉的更改，解决办法： git fask 或 git fask --unreachable 从列出的所有commit中找到被drop掉的那一个，假如被drop掉的是 526f16 git stash apply 526f16 Ok，现在可以看到，你的代码又回来了。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.agenric.cn/tags/Git/"}]},{"title":"静态网站的自动化构建","slug":"Static-website-automation-build","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2017/12/10/Static-website-automation-build/","link":"","permalink":"http://blog.agenric.cn/2017/12/10/Static-website-automation-build/","excerpt":"","text":"MkDocsMkDocs是什么MkDocs是一个轻量级的静态站点生成器，源码使用Markdown来撰写，可以说是相当的适合程序员使用了。 MkDocs快速搭建在本地快速的搭建起一个MkDocs服务：MkDocs依赖 Python 和 Python package manager pip 。 123456789101112131415161718192021222324252627282930313233343536373839// 先确保本地的Python和pip正常$ python --versionPython 2.7.10$ pip --versionpip 9.0.1 from /Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg (python 2.7)$ pip install mkdocs// 检测是否正确安装$ mkdocs --helpUsage: mkdocs [OPTIONS] COMMAND [ARGS]... MkDocs - Project documentation with Markdown.Options: -V, --version Show the version and exit. -q, --quiet Silence warnings -v, --verbose Enable verbose output -h, --help Show this message and exit.Commands: build Build the MkDocs documentation gh-deploy Deploy your documentation to GitHub Pages new Create a new MkDocs project serve Run the builtin development server// 创建一个项目$ mkdocs new MkDocsDocumentINFO - Creating project directory: MkDocsDocumentINFO - Writing config file: MkDocsDocument/mkdocs.ymlINFO - Writing initial docs: MkDocsDocument/docs/index.md$ cd MkDocsDocument// 查看生成的文件$ tree.├── docs│ └── index.md└── mkdocs.yml1 directory, 2 files OK，现在我假设你已经根据MkDocs的官方文档在本地搭建起来了一个本地服务，以上MkDocsDocument/docs/index.md 事实上就是你的主页，这时我们生成一下网站： 123$ mkdocs buildINFO - Cleaning site directoryINFO - Building documentation to directory: /Users/UserName/MkDocsDocument/site 接下来我们要把生成的静态文件push到远程： 1234$ cd site$ git init$ git remote add origin xxxxx... balabala 具体的git操作不再赘述。 OK，事实上我们这次主题并不是介绍MkDocs。 MkDocs自动构建起因本来我们一直用的hexo也是一个静态站点生成器，不过hexo比较成熟，在使用过程中我们可能并没有感到有什么不适应。然而mkdocs还处在成长阶段。每次写完文档之后，首先需要build，之后进入site文件夹，将该文件夹内生成的静态文件push到远程。如果频繁的更改文档之后就会很繁琐，所以很显然，借助CI来帮助我们。 所以我这次使用mkdocs作为实验品，来讲一下如何借助GitHub和Travis-CI帮我们实现自动构建。先假设我GitHub有一个仓库名MkDocsDocument来存放我的原始文档，有一个MkDocsSite来存放build之后生成的静态网站文件。GitHub和Travis-CI是一对好基友。所以我们的仓库在GitHub上就可以轻松的借助Travis-CI在我们每次push完代码之后帮我们部署。 Travis-CI 去Travis-CI官网注册一个账号，可以直接用GitHub身份登录。 初次登录之后，会跳转到一个拥有你GitHub所有仓库的一个列表，每一个项目前边都会有一个switch开关，你需要选择你想要同步的那个仓库，即你需要触发自动构建的那个仓库。 回到GitHub，注册token，因为我们需要CI可以访问到我们的项目，并且把build之后的静态HTML推送到GitHub。步骤：GitHub -&gt; Profile -&gt; Setting -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token。记得生成之后复制这个token保存起来，因为之后你就看不到了，像这样： 之后回到Travis-CI，设置这个仓库，对我来说就是设置MkDocsDocument，添加刚才我们生成的那个token，具体做什么用，可以看下边的yml文档。 编写Travis-CI的配置文件.travis.yml，比如我的配置文件如下： 1234567891011121314151617181920212223language: pythonpython: - \"2.7\"install: - pip install mkdocsscript: - mkdocs buildafter_script: - cp CNAME site/CNAME - cd site - git init - git config user.name \"Travis-CI\" - git config user.email \"agenricwon@gmail.com\" - git add . - git commit -m \"Update docs\" - git push \"https://$&#123;GITHUB_TOKEN&#125;@$&#123;GITHUB_REF&#125;\" master:masterenv: global: - GITHUB_REF: github.com/Agenric/MkDocsSite.git 我们看到after_script下第一行有一个cp操作，这是因为我为这个网站配置了一个自定义的二级域名，所以需要在网站的根目录下添加CNAME文件，不再多说。 现在我可以在本地的MkDocsDocument/docs文件夹中添加、更新、删除文件，之后git add、commit、push。喝一口咖啡，等着CI帮你自动build完成即可。 Done，至此，所有的步骤都完成了。","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.agenric.cn/categories/工具/"}],"tags":[{"name":"CI","slug":"CI","permalink":"http://blog.agenric.cn/tags/CI/"}]},{"title":"批量删除 Git 远程分支","slug":"Batch-delete-Git-remote-branch","date":"un55fin55","updated":"un11fin11","comments":true,"path":"2017/12/08/Batch-delete-Git-remote-branch/","link":"","permalink":"http://blog.agenric.cn/2017/12/08/Batch-delete-Git-remote-branch/","excerpt":"","text":"多人协作开发的过程中如果没有一个很好很规范的Git操作权限的管理，那么就很难避免不出现这样一种情况，所有人可以任意push、任意create branch、各种merge等等。 [我不管，我最酷。🙅🏻‍♂️] 这样一段时间之后你就会发现无论是自己本地还是远程都会出现一堆垃圾的分支，看着简直难受，强迫症根本受不了啊。所以，很显然我们不会去手动的一个一个分支的去删除，当然如果你一定要 git push origin :branchName 那你随意。 OK，批量删除，如何批量，首先我们需要列出我们需要删除的一系列分支。git branch -r 可以列出当前仓库下所有的远程分支，也就是说我们在这个列表里挑选出我们需要删除的某些分支。 所以，接着我们先列出符合自己想要删除符合某些规则的分支名。假如我的git远程地址默认是origin，那么其实在上一步 git branch -r 之后大概会长这样： 123456$ git branch -r origin/aaa origin/aaa/sss origin/bbb origin/ccc/ddd origin/eee/fff/ggg 比如我想删除所有a开头的分支，可以使用Linux的awk命令，先输出符合所有a开头的分支，可以这样： 123$ git branch -r| awk -F '[/]' '/origin\\/a/ &#123;printf \"%s\\n\", $2&#125;' origin/aaa origin/aaa/sss 至于 awk 命令的使用，请自行Google，我一般也是用到才会去查，翻手册。🤦‍♂️ 获得了想要删除的列表，最后一步就是执行删除操作了。所以完整命令： 12345$ git branch -r| awk -F '[/]' '/origin\\/a/ &#123;printf \"%s\\n\", $2&#125;' |xargs -I&#123;&#125; git push origin :&#123;&#125;To xxx.xxx.xxx.git - [deleted] aaaTo xxx.xxx.xxx.git - [deleted] aaa/sss 另外，多一句。删除本地分支无非就是最后的操作不一样：git branch -d 即可。 事实上，我感觉正规的协作流程就是在主仓库禁止所有developer执行push、create branch操作，所有开发人员从主库fork代码到自己的仓库，每个人维护自己的feature即可。需要进主库的feature提交mr即可。 Done !","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.agenric.cn/tags/Git/"}]},{"title":"AV Foundation 从0到1-播放和录制音频","slug":"AV-Foundation-from-zero-to-one-02","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2017/05/27/AV-Foundation-from-zero-to-one-02/","link":"","permalink":"http://blog.agenric.cn/2017/05/27/AV-Foundation-from-zero-to-one-02/","excerpt":"","text":"播放和录制音频AV Foundation定义了7种分类来描述应用程序所使用的音频行为： 分类 作用 是否允许混音 音频输入 音频输出 Ambient 游戏、效率应用程序 √ √ Solo Ambient（默认） 游戏、效率应用程序 √ Playback 音频和视频播放器 可选 √ Record 录音机、音频捕捉 √ Play and Record VoIP、语音聊天 可选 √ √ Audio Processing 离线会话处理 Multi-Route 使用外部硬件的高级A/V应用程序 √ √ 所有的iOS应用程序都自动带有一个默认的音频会话，分类名称为 Solo Ambient。 针对音频的播放和录制，一共有两个比较重要的类 AVAudioPlayer 和 AVAudioRecorder 。 AVAudioPlayer 可以播放本地的音频文件，不可以用来播放网络音频 播放中的控制修改播放器的音量： 播放器的音量独立于系统的音量，可以对 AVAudioPlayer 的 volume 属性值进行0.0（静音）~1.0（最大音量）的设置。 修改播放器的Pan值： 我们可以对 AVAudioPlayer 的 pan 属性值进行-1.0（极左）~1.0（极右）的设置，例如你在耳机中听到一辆车从你的左侧飞驰到右侧，那么就是这个值在起作用了。 调整播放率： 我们可以对 AVAudioPlayer 的 rate 属性值进行0.5（半速）~2.0（2倍速）的设置，即加速播放和减速播放。 调整循环模式： 我们可以对 AVAudioPlayer 的 numberOfLoops 值进行任意整数的设置，该属性值如果设置为大于0的数时则可以实现n此的循环播放，如果设置为-1则会导致无限循环。 音频计量： 我们可以通过设置 AVAudioPlayer 的 meteringEnabled 属性值的YES或NO，来决定是否读取当期播放的音频的 level metering。 等等… 前面我们说过，所有的iOS应用默认的音频会话分类为 Solo Ambient ，那么，很显然如果我们要做一款基于音频的应用的话，默认的分类是满足不了我们的要求的。所以我们最好在 didFinishedLaunch 方法中设置音频会话类型。即 AVAudioSessionCategoryXXX。然后记得激活会话。 其次如果我们需要在应用程序在后台运行的时候依然可以播放音频的话，我们需要在应用程序的 Info.plist 文件中添加一个新的 Required background modes 类型的数组，然后在数组中添加一个 App plays audio or streams audio/video using AirPlay 的选项。 处理中断事件有时候我们在播放音频的时候可能会被一些事情打断，比如说有电话呼入、有闹钟响起、有微信视频邀请等等…所以，处理中断事件是必须的，我们需要确保当前的音频播放被打断之后最好有一种比较友好的响应方式。 首先，我们要注册中断通知 AVAudioSessionInterruptionNotification ，通过判断 notification.userInfo 中的 AVAudioSessionInterruptionTypeKey 所对应的键值来确认当前的中断操作是开始还是结束。然后需要根据对应的操作来做出相应的处理。 处理线路改变假如说我们正在用手机播放音频，这时如果我插入了耳机那证明我这时候想切换到耳机来播放音频。反之，如果我正在使用耳机播放音频，这时我断开耳机的连接之后预期的结果应该是暂停播放。 同样，系统默认并不会帮我们做这些操作，这时需要注册线路变化通知 AVAudioSessionRouteChangeNotification ，该通知的userInfo字典中包含线路被切换的原因的 AVAudioSessionRouteChangeReasonKey 值。该值代表一个无符号的整数。 那么耳机断开这个事件对应的原因为 AVAudioSessionRouteChangeReasonOldDeviceUnavailable 。事实上，从这个原因的字面意思可以看出，这个通知其实告诉监听者的是旧的设备不可用而导致的线路改变，这也就是说其实耳机断开的事件相对于这个通知来说是充分不必要条件，什么意思呢，就是耳机断开会导致 AVAudioSession 发送该通知，但 AVAudioSession 发出该通知并不一定是因为耳机被断开。所以，你懂了？ 这样的话，我们在接收到该通知之后，必须再次向 notification.userInfo 提出请求，以获得其中用于描述前一个线路的 AVAudioSessionRouteDescription 。该描述信息整合了一个输入的 NSArray 和一个输出的 NSArray。数组中的元素都是 AVAudioSessionPortDescription 的实例，用于描述不同的I/O接口属性。 在 AVFoundation 框架的 AVAudioSession.h 文件中详细定义了 input port types 和 output port types 以及同时代表 input 和 output 的 port types that refer to either input or output 各种类型。 整个处理逻辑： 12345678910111213141516171819- (void)handleRouteChange:(NSNotification *)notification &#123; NSLog(@\"%s %@\", __func__, notification.userInfo); NSDictionary *info = notification.userInfo; AVAudioSessionRouteChangeReason reason = [info[AVAudioSessionRouteChangeReasonKey] unsignedIntegerValue]; if (reason == AVAudioSessionRouteChangeReasonOldDeviceUnavailable) &#123; AVAudioSessionRouteDescription *previousRoute = info[AVAudioSessionRouteChangePreviousRouteKey]; AVAudioSessionPortDescription *previousOutput = previousRoute.outputs[0]; NSString *portType = previousOutput.portType; if ([portType isEqualToString:AVAudioSessionPortHeadphones]) &#123; [self stop]; if (self.delegate) &#123; [self.delegate playbackStopped]; &#125; &#125; &#125;&#125; AVAudioRecorder相对于 AVAudioPlayer 的兄弟类。 AVAudioRecorder 可以使用设备内置的麦克风或外部音频设备（比如数字音频接口或USB麦克风等）进行录制。 创建 AVAudioRecorder 实例时需要为其提供数据的一些信息，分别是： 用于表示音频流写入文件的本地 URL。 包含用于配置录音会话键值信息的 NSDictionary 对象。 用于捕捉初始化阶段各种错误的 NSError 指针。 同样，在初始化完成之后，立即调用 prepareToRecord 方法，会将录制启动时的延时降到最小。 在上边第二条，配置录音会话键值信息的 NSDictionary 对象这一步中的键值信息也值得讨论一番。我们只简要的来看一些基本的键值信息。 音频格式： AVFormatKey 采样率： AVSampleRateKey 标准的采样率一般有8000、16000、22050或44100几种。 通道数： AVNumberOfChannelKey 指定默认值1意味着单声道录制，设置2意味着使用立体声录制。除非使用外部硬件进行录制，否则通常应该创建单声道录音。 位深度： AVEncoderBitDepthHintKey 可以理解为计算机声卡处理声音的解析度。这个数值越大，解析度就越高，录制和回放的声音就越真实。 等等… 先回到创建 AVAudioRecorder 实例时我们提供的音频流的本地 URL，一般该 URL 最好是在 tmp 文件夹。在录制完成之后，通常将该文件复制到 Documents 文件夹中保存。音频录制同样支持暂停，调用 AVAudioRecorder 的 pause 方法即可暂停录制，再次调用 record 方法即可继续录制。通常我们在录制完成时最好能给用户一个友好的提示告诉他录制完成，并请求用户完成保存前的一些操作（命名）。 相对于音频播放来说，音频录制可能要说的东西并没有很多。接下来我们看一下 Audio Metering。 Audio MeteringAudio Metering 堪称 AVAudioRecorder 和 AVAudioPlayer 中最强大和最实用的功能。Audio Metering 可以让开发者读取音频的平均分贝和峰值分贝数据。开发者可以根据这些数据以可视化的方式将声音的大小波动效果呈献给用户。 两个类使用的方法都是 averagePowerForChannel: 和 peakPowerForChannel: 。两个方法都会返回一个表示分贝(dB)等级的浮点值。这个范围从表示最大分贝的0dB(fullscale)到表示最小分贝或静音的-160dB。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"AV Foundation","slug":"AV-Foundation","permalink":"http://blog.agenric.cn/tags/AV-Foundation/"}]},{"title":"AV Foundation 从0到1-入门","slug":"AV-Foundation-from-zero-to-one-01","date":"un55fin55","updated":"un11fin11","comments":true,"path":"2017/05/26/AV-Foundation-from-zero-to-one-01/","link":"","permalink":"http://blog.agenric.cn/2017/05/26/AV-Foundation-from-zero-to-one-01/","excerpt":"","text":"本系列文章仅为记录学习过程中的点滴，《AV Foundation 开发秘籍》读书笔记 入门简介AV Foundation是苹果OS X和iOS系统中用于处理基于时间的媒体数据的高级Objective-C的框架。利用多核硬件的优势并且大量使用block和GCD机制来保证程序的运行性能，基于64位的处理器设计。 支撑框架及其功能 Core Audio 音频事件的框架，为音频和MIDI内容的录制播放和处理提供相应的接口。通过Audio Units接口可以对音频信号进行完全的控制，同时可以构建复杂的音频处理模式。 Core Video 视频事件的框架，对数字视频所提供的管道模式。Core Video为其相对的Core Media提供图片缓存和缓存池的支持，其还提供了一个能够对数字视频逐帧访问的接口 Core Media AV Foundation所用到的低层级媒体管道的一部分。提供针对音频样本和视频帧处理所需的低层级数据类型和接口。还提供了基于CMTime数据类型的时基模型。 Core Animation 合成及动画的相关框架。提供全平台所具有的美观、流畅的动画效果。 处于高层级框架(AVKit)和低层经框架(Core Audio等)之间的就是AV Foundation。 解析AV FoundationAV Foundation提供的一些核心功能包括音频的播放与记录、媒体文件检查、视频播放、媒体捕捉、媒体编辑媒体处理等。既有上层可以满足一般开发者需求的API，同时还为可能有更高需求、需要定制开发的部分开发者提供低层级的服务。 了解数字媒体媒体内容最初是如何被数字化的？ 人们处在一个数字化的时代，却还是更习惯模拟信息的世界，人们的所见所闻（听）都是通过模拟信号船体给我们的。 将模拟信号转换成我们能够存储的的数字信号，要经过模拟-数字装换过程，这个过程就叫做采样。 数字媒体采样：媒体数字化采样主要有时间采样和空间采样。时间采样是捕捉一个信号周期内的变化。空间采样即在一定的分辨率下对某一幅画面进行亮度和色度的捕捉，进而构建成包含该图像像素点数据的数字化结果。一般当我们对一段视频进行数字化时会同时使用这两种方式，因为通常的视频信号既有时间属性也有空间属性。 数字媒体压缩数字媒体压缩，无论是针对声音媒体还是视频媒体都有普遍的两张压缩方式：有损压缩、无损压缩。 视频数据采样基本都是采用YUV的颜色编码方式，其中“Y”表示明亮度（Luminance、Luma），“U”和“V”则是色度、浓度（Chrominance、Chroma）。 对于视频来说，常见的编解码格式可以归结为H.264和AppleProRes。 H.264分别通过在空间、时间两个维度进行压缩。 空间：压缩独立视频帧，被称为帧内压缩。 时间：通过以组为单位的视频帧压缩冗余数据，被称为帧间压缩。 目前已经基本成为行业内通用标准，它通过消除包含在每个独立视频帧内的色彩及结构中的冗余信息来进行压缩，因此可在不降低图片质量的情况下尽可能缩小尺寸。 在帧间压缩中，很多帧被组合在一起作为一组图片（简称GOP），对于GOP所存在的时间维度的冗余可以被消除。 其中，对于GOP，存储在其中的共有三种不同类型的帧: I帧：即关键帧。包含创建完整图片所需要的所有数据。每个GOP中都正好有且仅有一个I帧。由于它是一个独立的帧，其尺寸是最大的，但也是解压最快的。 P帧：即预测帧。是从基于最近的I帧或P帧的可预测的图片进行编码得到的。P帧可以引用最近的预测P帧或一组I帧。你将会经常看到这些被称为“reference frames”的帧，临近的P帧和B帧都可以对其引用。 B帧：双向帧。是基于其之前和之后的帧信息进行编码得到的。几乎不需要存储空间，但其解压过程会耗费较长时间，因为他的大部分信息都依赖周围其他的帧。 Apple ProRes被认为是一个中间件或中间层编解码器，因为他的目的是为专业编辑和生产工作流服务的。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"AV Foundation","slug":"AV-Foundation","permalink":"http://blog.agenric.cn/tags/AV-Foundation/"}]},{"title":"如何更好的适配 HTTPS 之证书验证","slug":"How-to-better-adapter-HTTPS","date":"un44fin44","updated":"un11fin11","comments":true,"path":"2017/04/20/How-to-better-adapter-HTTPS/","link":"","permalink":"http://blog.agenric.cn/2017/04/20/How-to-better-adapter-HTTPS/","excerpt":"","text":"早在去年（2016）年底，关于Apple要求所有的开发者在2017-01-01之前务必将App Store上的APP适配HTTPS。然而… 结果大家现在都知道了呗，而且当时论坛有同学贴出针对此事咨询Apple的回复邮件，邮件中告知并没有… But，不管怎样，是时候给你的APP穿上一层保护衣了。 关于如何适配HTTPS，许多前辈都已经讲的非常好了，本人文笔拙劣，就不再赘述。 然后我想说的是关于HTTPS证书的验证。 先来看一下客户端与服务器进行HTTPS连接的握手过程：（图片来自网络） 第三步，证书校验。客户端验证证书的合法性，如果验证通过之后才会进行后续通信。 如果我们用的是权威机构颁发的证书，那么之前很可能这样做： 12AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] init];manager.securityPolicy = [AFSecurityPolicy defaultPolicy]; 然而，这根本抵挡不了代理工具的查（gong）看（ji）。 使用Charles配置SSL Proxy Setting添加对应的域名，客户端安装一个Charles颁发的根证书并且信任之后，这两句话就形同虚设了，这种操作对应稍微有点经验的软件从业者来说根本不是什么难事。 因为证书校验过程中，客户端会检查服务端发来的证书是不是可信任机构颁发的、证书中的域名与实际域名是否一致、证书是否已经过期之类的，而因为你提前已经安装并且信任了Charles给你的根证书，所以这时候你再拿着Charles给你的证书去做匹配，那么系统本地当然会告诉你这个证书是可信任的。 如何避免这种情况呢，这就说到了本地的证书校验，我们可以直接把CA给你签发的数字证书内置到手机中，并且作为信任的证书，这样当我们再次收到服务端（实际上是Charles）返回给我们证书时，我们会这样做： 12345678AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] init];NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"key\" ofType:@\"cer\"];//证书的路径NSData *cerData = [NSData dataWithContentsOfFile:cerPath];AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];securityPolicy.allowInvalidCertificates = NO; // 是否需要验证自建证书securityPolicy.validatesDomainName = NO; // 是否需要验证域名securityPolicy.pinnedCertificates = [NSSet setWithObject:cerData];manager.securityPolicy = securityPolicy; 完了之后，我们的APP就会发现，这不是我们服务器的证书，这丫会不会是个骗子，从而终止连接。 这样的话，新的问题又来了，如果我们使用的是权威机构颁发的证书，这个证书肯定是有有效期的，普通公司的证书一般有效期都是1年，逐年更新，那么一旦证书失效，这个验证就会失败，这样直接造成我们的APP不能用了，虽然我们可以通过提前更换新版本强制更新来解决，但这毕竟是非正常手段。我们总不能因为这个问题每年来一次强制更新吧，当然如果产品和市场抛开用户体验不谈的话就当我没说。 当然，你如果用的是自签名的证书，就可以轻而易举的解决这个问题，比如说你给自己签一个有效期50年的证书，50年来一次大改版强制更新不足为奇吧，并且重要的是50年后即便出了问题也不是我们的锅了，天知道那时候你是不是回家养老了，哈哈，扯远了，拉回来…… 然而，并不是每个人都喜欢用自签名的证书，毕竟这样的证书如果你在浏览器打开，就会有一个红叉叉告诉你这个网站不安全。我司老板就是这样的人，所以我们的证书是权威机构购买的，而且老板大手一挥就是一个通配符的。（并没有炫耀的嫌疑） 事实上还有另外一种方法，而且我司现在用的也正是这种方法，当然需要一个前提就是，假如你的证书快要到期，需要续期的时候，买的还是同一家的同一款产品才行。 其实我们可以看到，AFSSLPinningMode有三个可选项，分别是： AFSSLPinningModeNone：代表客户端无条件信任服务器端返回的证书。 AFSSLPinningModePublicKey：代表客户端仅对证书进行PublicKey部分的验证，只要PublicKey部分校验正确，就会继续执行。 AFSSLPinningModeCertificate：代表客户端会对证书所有内容，包括PublicKey和证书部分都进行校验，如果校验正确，就会继续执行。 对，我们选择，AFSSLPinningModePublicKey这种模式，然后需要把给我们签发证书的机构的证书打包进APP里。 上一张图，以Baidu.com的证书为例子： 我们看到baidu的证书是从一家名叫GlobalSign的SSL证书签发商签发的，一般来说，现在大多数的CA并不使用根证书直接签署证书，而是签署中间CA，由中间的CA来再次签署服务器证书，这样即使根证书出现了某些问题，也可以用根证书重新签署中间证书。 那么实际上，在HTTPS握手开始后，服务端会把整个证书链给到客户端去做校验。校验的过程就是要找到是否存在这样一条证书链，链中的每个相邻节点，上级的公钥可以校验通过下级的证书，链的根节点是设备信任的锚点或者根节点可以被锚点校验，事实上锚点对应浏览器来说就是内置的根证书。 这样的话如果我们把给我们签署服务端证书的父级证书（即CA机构的中间证书）放在客户端本地作为我们验证的锚点，对比上图中的GlobalSign Organization Validation CA - SHA256 - G2。这样之后不仅可以预防代理人的中间攻击，还不用担心日后证书过期更换证书带来的麻烦。 这样仔细想一下，未尝不是一个好的解决方案。只要遵守上文中我说的那个前提，还是从同一家的同一个中间CA签发的证书，就一切OK。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"http://blog.agenric.cn/tags/HTTPS/"}]},{"title":"Effective Objective-C 2.0 要点摘录","slug":"Effective-Objective-C-2.0-main-point","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2017/04/18/Effective-Objective-C-2.0-main-point/","link":"","permalink":"http://blog.agenric.cn/2017/04/18/Effective-Objective-C-2.0-main-point/","excerpt":"","text":"了解 Objective-C 语言的起源 Objective-C 为 C 语言添加了面向对象的特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境决定而非编译器决定。 理解 C 语言的核心概念有助于写好 Objective-C 程序。尤其要掌握内存模型与指针。 在类的头文件中尽量少引入其他头文件 除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合。 有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把 “该类遵循某协议” 的这条声明移至 “class-continuation 分类” 中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。 多用字面量语法，少用与之等价的方法 应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。 应该通过下标操作来访问数组下标或字典中的键所对应的元素。 用字面量语法创建数组或字典时，若值中有 nil，则会抛出异常。因此务必确保值里不含 nil。 多用类型常量，少用 #define 预处理指令 不要使用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此进行查找与替换的操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。 在实现文件中使用 static const 来定义 “只在编译单元内可见的常量”（translation-unit-specific constant）。由于此类常量不在全局符号表中，所以无须为其名称加前缀。 在头文件中使用 exten 来声明全局变量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀。 用枚举表示状态、选项、状态码 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。 如果把传递给某个方法的选项表示为枚举类型，而多个选项有可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。 用 NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层的数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。 在处理枚举类型的 switch 语句中不要实现 default 分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch 语句并未处理所有枚举。 理解 “属性” 这一概念 具备 readwrite（读写）特质的的属性拥有 “获取方法”（getter）与 “设置方法”（setter）。若该属性由 @synthesize 实现，则编译器会自动生成这两个方法。 具备 readonly（只读）特质的属性仅用于获取方法，只有当该属性由 @synthesize 实现时，编译器才会为其合成获取方法。你可以用此特质把某个属性对外公开为只读属性，然后在 “class-continuation 分类” 中将其重新定义为读写属性。 assign “设置方法” 只会执行针对 “纯量类型”（scalar type，例如 CGFloat 或 NSInteger 等）的简单赋值操作。 strong 此特质表明该属性定义了一种 “拥有关系”（owning relationship）。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。 weak 此特质表明该属性定义了一种 “非拥有关系”（nonowning relationship）。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似，然而在属性所指的对象遭到摧毁时，属性值也会清空（nil out）。 unsafe_unretained 此特质的语义和 assign 相同，但是它适用于 “对象类型”（object type），该特质表达一种 “非拥有关系”（“不保留”，unretained），当目标对象遭到摧毁时，属性值不会自动清空（“不安全”，unsafe），这一点与 weak 有区别。 copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其 “拷贝”（copy）。当属性类型为 NSString * 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时候就要拷贝一份 “不可变”（immutable）的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是 “可变的”（mutable），就应该在设置新属性值时拷贝一份。 getter=&lt;name> 制定 “获取方法” 的方法名。如果某属性时 Boolean 型，而你想为其获取方法上加上 “is” 前缀，那么就可以使用这个办法来指定。比如说，在 UISwitch 类中，表示 “开关”（switch）是否打开的属性值就是这样定义的：@property (nonatomic, getter=isOn) BOOL on; setter=&lt;name> 指定 “设置方法” 的方法名。这种用法不太常见。 可以用 @property 语法来定义对象中所封装的数据。 通过 “特质” 来指定存储数据所需要的正确语义。 在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。 开发 iOS 程序时应该使用 nonatomic 属性，因为 atomic 属性会严重影响性能。 在对象内部尽量直接访问实例变量 由于不经过 Objective-C 的 “方法派发”（method dispatch）步骤，所以直接访问实例变量的速度当然比较快。在这种情况下，编译器所产生的代码会直接访问保存对象实例变量的那块内存。 直接访问实例变量时，不会调用其 “设置方法”，这就绕过了为相关属性所定义的 “内存呢管理语义”。比方说，如果在 ARC 下直接访问一个声明为 copy 的属性，那么并不会拷贝该属性，只会保留新值并释放旧值。 如果直接访问实例变量，那么不会触发 “键值规则”（Key-Value Observing，KVO）通知。这样做是否会产生问题，还取决于具体的对象行为。 通过属性来访问有助于排查与之相关的错误，因为可以给 “获取方法” 和/或 “设置方法” 中新增 “断点”（breakpoint），监控该属性的调用者及其访问时机。 在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时则应通过属性来写。 在初始化方法及 dealloc 方法中，总是应该直接通过实例变量来读写数据。 有时会使用惰性初始化技术配置某份数据，在这种情况下，需要通过属性来读取数据。 事实上，我个人在开发中并不推崇这种模式。我几乎全部使用惰性初始化技术，通常我会在类的内部使用这种技术重写几乎所有属性的 getter 方法，只在其 getter 方法内部直接使用实例变量，而在之外的所有地方都使用点语法来读写它们。这样无论是从代码风格上、还是美观性、一致性上都相对较好。 理解 “对象等同性” 这一概念 若要检测对象的等同性，请提供 “isEqual：” 与 hash 方法。 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。 不要盲目的逐个检测每条属性，而是应该依照具体需求来制定检测方案。 编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。 以 “类族模式” 隐藏实现细节 增加某一类族的子类时，需要遵循： 子类应该继承自类族中的抽象基类。 子类应该定义自己的数据存储方式。 子类应当覆写超类文档中指明需要覆写的方法。 类族模式可以吧实现细节隐藏在一套简单的公共接口后面。 系统框架中经常使用类族。 从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。 在既有类中使用关联对象存放自定义数据 | 关联类型 | 等效的@property属性 || ——————————— | ——————— || OBJC_ASSOCIATION_ASSIGN | assign || OBJC_ASSOCIATION_RETAIN_NONATOMIC | nonatomic, retain || OBJC_ASSOCIATION_COPY_NONATOMIC | nonatomic, copy || OBJC_ASSOCIATION_RETAIN | retain || OBJC_ASSOCIATION_COPY | copy | 下列方法可以管理关联对象： void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy) 此方法以给定的键和策略为某对象设置关联对象值。 id objc_getAssociatedObject(id object, void *key) 此方法根据给定的键从某对象中获取相应的关联对象值。 void objc_removeAssociatedObjects(id object) 此方法移除指定对象的全部关联对象。 可以通过 “关联对象” 机制来把两个对象连起来。 定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的 “拥有关系” 与 “非拥有关系”。 只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的 bug。 理解 objc_msgSend 的作用 objc_msgSend_stret。如果待发送的消息要返回结构体，那么可交由此函数处理。只有当 CPU 的寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于 CPU 寄存器中（比如说返回的结构体太大了），那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。 objc_msgSend_fpret。如果消息返回的是浮点数，那么可交由此函数处理。在某些架构的 CPU 中调用函数时，需要对 “浮点数寄存器”（floating-point register）做特殊处理，也就是说，通常所用的 objc_msgSend 在这种情况下并不适合。这个函数是为了处理 x86 等架构 CPU 中某些令人稍觉惊讶的奇怪情况。 objc_msgSendSuper。如果要给超类发消息，例如 [super message:parameter]，那么就交由此函数处理。也有另外两个与 objc_msgSend_stret 和 objc_msgSend_fpret 等效的函数，用于处理发送给 super 的相应消息。 消息由接收者、选择子及参数构成。给某对象 “发送消息”（invoke a message）也就相当于在该对象上 “调用方法”（call a method）。 发给某对象的全部消息都要由 “动态消息派发系统”（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。 理解消息转发机制 若对象无法响应某个选择子，则进入消息转发流程。 通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。 对象可以把其无法解读的某些选择子转交给其他对象来处理。 经过上述两步之后，如果还是没办法处理选择子，那就启动完整的消息转发机制。 用 “方法调配技术” 调试 “黑盒方法” 在运行期，可以向类中新增或替换选择子所对应的方法实现。 使用另一份实现来替换原有的方法实现，这道工序叫做 “方法调配”，开发者常用此技术向原有实现中添加新功能。 一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。 理解 “类对象” 的用意 每个实例都有一个指向 Class 对象的指针，用以表明其类型，而这些 Class 对象则构成了类的继承体系。 如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。 尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。 用前缀避免命名空间冲突 选择与你的公司、应用程序或二者皆有关联之名称做为类名的前缀。 若自己开发的程序库中用到了第三方库，则应为其中的名称加上前缀。 提供 “全能初始化（Designated Initializer）方法” 在类中提供一个全能初始化方法，并于文档里声明。其他初始化方法均应调用此方法。 若全能初始化方法与超类不同，则需覆写超类中的对应方法。 如果超类的初始化方法不适用子类，那么应该覆写这个超类方法，并在其中抛出异常。 实现 description 方法 实现 description 方法返回一个有意义的字符串，用以描述该实例。 若想在调试时打印出更详尽的对象描述信息，则应该实现 debugDescription 方法。 尽量使用不可变对象 尽量创建不可变的对象。 若某属性仅可于对象内部修改，则在 “class-continuation 分类” 中将其由 readonly 属性扩展为 readwrite 属性。 不要把可变的 collection 作为属性公开，而应提供相关方法，以此修改对象中的可变 collection。 使用清晰而协调的命名方式 起名时应遵从标准的 Objective-C 命名规范，这样创建出来的接口更容易为开发者所理解。 方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好。 方法名里不要使用缩略后的类型名称。 给方法起名时的第一要务就是确保其风格与你自己的代码或所需要集成的框架相符。 为私有方法名加前缀 给私有方法的名称加前缀，这样可以很容易地将其同公共方法区分开。 不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司使用的。 理解 Objective-C 错误类型 只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。 在错误不那么严重的情况下，可以指派 “委托方法”（delegate method）来处理错误，也可以把错误信息放在 NSError 对象里，经由 “输出参数” 返回给调用者。 理解 NSCopying 协议 若想令自己所写的对象具有拷贝功能，则需要实现 NSCopying 协议。 如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。 复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应该尽量执行浅拷贝。 如果你所写的对象需要深拷贝，那么可以考虑新增一个专门执行深拷贝的方法。 通过委托与数据源协议进行对象间通信 委托模式为对象提供了一套接口，使其可由此将相关事件 告知其他对象。 将委托对象应该值的接口定义成协议，在协议中把可能需要处理的事件定义成方法。 当某对象需要从另外一个对象中获取数据时，可以使用委托模式。这种情境下，该模式亦称 “数据源协议”（data source protocal）。 若有必要，可实现含有段位的结构体，将委托对象是否能够响应相关协议这一信息缓存至其中。 将类的实现代码分散到便于管理的数个分类之中 使用分类机制把类的实现代码划分成易于管理的小块。 将应该视为 “私有” 的方法归入名叫 Private 的分类中，以隐藏实现细节。 总是为第三方类的分类名称加前缀 向第三方类中添加分类时，总应给其名称加上你专用的前缀。 向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。 勿在分类中声明属性 把封装数据所用的全部属性都定义在主接口里。 在 “class-continuation 分类” 之外的其他分类中，可以定义存取方法，但尽量不要定义属性。 使用 “class-continuation 分类” 隐藏实现细节 通过 “class-continuation 分类” 向类中新增实例变量。 如果某属性在主接口中声明为 “只读”，而类的内部又要用设置方法修改此属性，那么就在 “class-continuation 分类” 中将其扩展为 “可读写”。 把私有方法的原型声明在 “class-continuation 分类” 里面。 若想使类所遵循的协议不为人所知，则可于 “class-continuation 分类” 中声明。 通过协议提供匿名对象 协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。 使用匿名对象来隐藏类型名称（或类名）。 如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。 理解引用计数 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。 在对象生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。 以 ARC 简化引用计数 在应用程序中，可以用下列修饰符来改变局部变量与实例变量的语义： __strong：默认语义，保留此值。 __unsafe_retained：不保留此值，这么做可能不安全，因为等到再次使用变量时，其对象可能已经回收了。 __weak：不保留此值，但是变量可以安全使用，因为如果系统把这个对象回收了，那么变量也会自动清空。 __autoreleasing：把对象 “按引用传递”（pass by reference）给方法时，使用这个特殊的修饰符。此值在方法返回时自动释放。 有 ARC 之后，程序员就无须担心内存管理问题了。使用 ARC 来编程，可省去类中的许多 “样板代码”。 ARC 管理对象生命期的办法基本上就是：在合适的地方插入 “保留” 及 “释放” 操作。在 ARC 环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行 “保留” 及 “释放” 操作。 由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC 将此确定为开发者必须遵守的规则。 ARC 只负责管理 Objective-C 对象的内存。尤其要注意：CoreFoundation 对象不归 ARC 管理，开发者必须适时调用 CFRetain/CFRelease。 在 dealloc 方法中只释放引用并解除监听 在 dealloc 方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的 “键值观测”（KVO）或 NSNotificationCenter 等通知，不要做其他事情。 如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用 close 方法。 执行异步任务的方法不应该在 dealloc 方法内调用；只能在正常状态下执行的那些方法也不应在 dealloc 里调用，因为此时对象已经处于正在回收的状态了。 编写 “异常安全代码” 时留意内存管理的问题 捕获异常时，一定要注意将 try 块内所创立的对象清理干净。 在默认情况下，ARC 不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。 以弱引用避免保留环 将某些引用设置为 weak，可避免出现 “保留环”。 weak 引用可以自动清空，也可以不自动清空。自动清空（autonilling）是随着 ARC 而引入的特性，由运行期系统来实现。在具备自动清空功能的若引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。 以 “自动释放池块” 降低内存峰值 自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入最顶端的池里。 合理运用自动释放池，可降低应用程序的内存峰值。 @autoreleasepool 这种新式写法能创建出更为轻便的自动释放池。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.agenric.cn/tags/iOS/"}]},{"title":"自定义统一分享平台","slug":"Unified-Share-Desk","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2017/04/02/Unified-Share-Desk/","link":"","permalink":"http://blog.agenric.cn/2017/04/02/Unified-Share-Desk/","excerpt":"","text":"鉴于社交网络现在的强大（淫威），现在市面上的APP，分享到社交网络的这个功能可以说是标配。期初我司的APP在添加分享这一块的功能时，leader说咱们开发人员少、工期紧（敏捷开发嘛，大家都懂…），这块就用网上现成的吧，什么友盟啊之类的就行。 暂且不说这期间的种种… 因为我们的需求仅仅是分享一个带有url的string。我就在想，有没有必要因为一个这么小的需求去使用一个体量很大的第三方。宽且是对于我这样一个有略微强迫症的人来说，这太影响代码美观了。哈哈，其实可能并没有… 然而，最终还是没有用，所以我才把这个玩意儿整理出来，感觉拖了n年。 整个AGShareDesk提供三个方法： 123456789// 注册- (void)registerWithWeiboAppKey:(NSString *)weiboAppKey weChatAppKey:(NSString *)weChatAppKey tencentAppId:(NSString *)tencentAppId;// 分享- (void)shareToChannel:(ShareChannel)shareChannel withMessgaeObject:(ShareMessageObject *)message afterDelegate:(id&lt;AGShareDeskDelegate&gt;)afterDelegate;// 处理分享结果- (void)handleApplication:(UIApplication *)application withOpenURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options; 然后会有一个ShareMessageObject，在你分享之前，你需要创建一个 ShareMessageObject 的对象，该对象可以设置分享的标题、内容、链接以及logo的图片，ShareMessageObject 仅提供一个类方法返回一个该对象的实例。 整体来说就是把之前散落在个个地方的代码整合起来，你只需在 AppDelegate.m 中的 didFinishLaunch 中注册你在各个平台申请的key，然后在 openURL 中告诉 ShareDesk 去处理分享之后的回调即可。其余的所有工作都在 ShareDesk 内部完成。 你可以使用 pod &quot;AGShareDesk&quot;来使用它。如果不能满足你的需求也希望能给你一个参考，完整代码在这里 PS上文已经谈过，业务需求很简单，所以并没有做很丰富的分享，如果你有其他类型的需求，那么希望这个项目能给你一个参考，如果真的没什么可参考的，那，那就算了…反正能说的我都说了。哈哈","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"iOS小知识","slug":"iOS小知识","permalink":"http://blog.agenric.cn/tags/iOS小知识/"}]},{"title":"基于 CocoaPods 的公司内部开发流程","slug":"CocoaPods-based-in-house-development-process","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2017/03/14/CocoaPods-based-in-house-development-process/","link":"","permalink":"http://blog.agenric.cn/2017/03/14/CocoaPods-based-in-house-development-process/","excerpt":"","text":"CocoaPods作为 OS X 和 iOS 下的一个知名的第三方库管理工具早已被大家所熟知，那么在公司内部如何能够刚好的使用CocoaPods为我们的开发提供服务呢。 基于CocoaPods的流程简介一般来说个公司都会有自己的git托管服务器类似gitlab。那么我认为正常的流程是这样的，如下图： 事实上，上图应该分成两个部分来看： 第一部分：比如说我有项目名称叫 XXXMainProject 需要引用一个公开仓库类似github上的一个组件，那么要做的第一步是在fork一份代码然后clone到本地，在一个你认为稳定的分支下checkout出一个新的分支例如上图，我需要使用 XXXLibProject ，那么我在当前master分支上checkout出一个新的分支le_project，然后把这个仓库连同新的分支推送到自己公司的私有服务器上，这样做有很多好处，比如我你可以在别人的组件库的基础上，再针对自己项目的需求进行定制，同时也可以避免其他一些不可预知的麻烦（比如说某一天这个组件库被作者删掉了 :) ，虽然这种几率几乎不可能发生，如果真的发生在你身上，那我感觉你有可能是fork了一个假项目）。 第二部分：我fork的这个项目已经推送到自己公司的私有服务器上了，接下来就是我要在项目中引用这个组件。首先在本地执行pod repo add LeRepo https://gitlab.xxx.com/agenric/LeRepo.git添加一个私有的CocoaPods仓库并命名为LeRepo，然后修改clone到本地的库的podspec文件中s.source的:git的值为私有服务器的地址。这一系列操作执行完成之后需要的就是把你开发完成之后的代码告诉你自己私有的CocoaPods仓库，pod repo push LeRepo XXXLibProject.podspec添加一条索引，这样之后，就可以在主项目中使用pod &#39;XXXLibProject&#39;来加载这个组件库了。 那么，为什么要使用这种模式呢。一般情况下我们的一个项目可能会引用很多组件库，那么就需要一个私有的中心库来统一管理这些组件库。在上图中Private中的LeRepo就是我们的私有中心库，用来管理其他的组件库。 创建私有的远程中心库 注意这个远程地址是只能在公司内网环境下才能访问的地址 首先查看本地repo列表，这时候只有一个CocoaPods公开的master库 1234567$ pod repo listmaster- Type: git (master)- URL: https://github.com/CocoaPods/Specs.git- Path: /Users/Agenric/.cocoapods/repos/master1 repo 添加私有repo 1$ pod repo add LeRepo https://gitlab.xxx.com/agenric/LeRepo.git 之后再次查看repo的列表 123456789101112131415$ pod repo listLeRepofatal: ambiguous argument 'HEAD': unknown revision or path not in the working tree.Use '--' to separate paths from revisions, like this:'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'- Type: git (unknown)- URL: https://gitlab.xxx.com/xxx.git- Path: /Users/Agenric/.cocoapods/repos/LeRepomaster- Type: git (master)- URL: https://github.com/CocoaPods/Specs.git- Path: /Users/Agenric/.cocoapods/repos/master2 repos 因为现在的仓库还是空的，所以会提示错误，不过不用担心，稍后回来。这时候打开Finder。进入~/.cocoapods/repos 新创建的LeRepo已经在repos文件夹下了。 创建私有的组件库接着我们来创建一个组件库在本地，组件库的创建有两种情况： 组件库已将开发完毕，我们之间把代码抽取出来，放到固定位置，然后创建一个XXXLibProject.podspec 组件库还未开发，我们可以通过pod lib create XXXLibProject创建，此种方式创建之后，他会从github上克隆一个模板例子，这中间会询问你一系列问题： 12345What language do you want to use?? [ Swift / ObjC ]Would you like to include a demo application with your library? [ Yes / No ]Which testing frameworks will you use? [ Specta / Kiwi / None ]Would you like to do view based testing? [ Yes / No ]What is your class prefix? 中括号中的首选项为默认选项，如果你直接点击回车，则默认选中第一项。在这里语言我选择使用了oc，其余选项均为默认。 创建之后，Xcode文件结构如下图： 看到Podfile中引用XXXLibProject是通过本地path的方式引入的。也就是说在该项目下执行pod install之后，直接会从Podfile文件所在文件夹的上一级XXXLibProject文件夹中直接引入。 在Finder中文件结构如下： 以上箭头所指的文件夹即是pod的索引目录，这里我创建两个测试文件。 12345678910111213141516// XXXLog.h#import &lt;Foundation/Foundation.h&gt;@interface XXXLog : NSObject+ (void)log;@end // XXXLog.m#import \"XXXLog.h\"@implementation XXXLog+ (void)log &#123; NSLog(@\"This is an example for Pod Test Library.\");&#125;@end 然后退出在根目录执行pod install。打开之后可以看到XXXLibProject已经通过本地文件的方式引入进项目。在测试项目中我们已经可以开始使用这个组件。 发布自定义的组件库到私有的CocoaPods仓库组件库我们开发完成之后我们要做的就是把组件库推送到私有的CocoaPods库。 打开Example文件夹中的podspec文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344## Be sure to run `pod lib lint XXXLibProject.podspec' to ensure this is a# valid spec before submitting.## Any lines starting with a # are optional, but their use is encouraged# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html#Pod::Spec.new do |s| s.name = 'XXXLibProject' #名称 s.version = '0.1.0' #版本号 s.summary = 'A short description of XXXLibProject.' #简短介绍# This description is used to generate tags and improve search results.# * Think: What does it do? Why did you write it? What is the focus?# * Try to keep it short, snappy and to the point.# * Write the description between the DESC delimiters below.# * Finally, don't worry about the indent, CocoaPods strips it! s.description = &lt;&lt;-DESC This is an example for Pod Test Library. This is an example for Pod Test Library. This is an example for Pod Test Library. DESC #详细介绍 s.homepage = 'https://gitlab.xxx.com/agenric/XXXLibProject' #主页,这里要填写可以访问到的地址，确保验证通过 # s.screenshots = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2' s.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125; #开源协议 s.author = &#123; 'agenric' =&gt; 'AgenricWon@gmail.com' &#125; #作者信息 s.source = &#123; :git =&gt; 'https://gitlab.xxx.com/agenric/XXXLibProject.git', :tag =&gt; s.version.to_s &#125; #项⽬地址，这⾥不支持ssh协议，只支持HTTP和HTTPS # s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;' #多媒体介绍地址 s.ios.deployment_target = '8.0' #⽀持的最低版本 s.source_files = 'XXXLibProject/Classes/**/*' #代码源⽂文件地址，**/*表示Classes 目录及其⼦目录下所有文件，如果有多个目录下则⽤逗号分开，如果需要在项目中分组显示，这⾥也要做相应的设置 # s.resource_bundles = &#123; # 'XXXLibProject' =&gt; ['XXXLibProject/Assets/*.png'] #资源⽂文件地址 # &#125; # s.public_header_files = 'Pod/Classes/**/*.h' #公开头⽂文件地址 # s.frameworks = 'UIKit', 'MapKit' #所需的framework，多个⽤用逗号隔开 # s.dependency 'AFNetworking', '~&gt; 2.3' #依赖关系，该项⽬目所依赖的其他库，如 果有多个需要填写多个s.dependencyend 以上文件中部分字段我已经标注了注释，隐私原因部分url做了修改，你也可以去这里查看更加详细的说明。 podspec文件验证编辑完podspec文件之后，需要验证一下这个文件是否可用，如果有Warring或error都是不可以的。验证命令： 1234$ pod lib lint -&gt; XXXLibProject (0.1.0)XXXLibProject passed validation. 当你看到这个提示时，说明这个podspec文件是合格的，验证通过了。 向Spec Repo提交podspec当确定组件库没有问题时，我们就可以把podspec提交给自己的私有repo的远程库了。 但是在这之前我们要先把组件库的代码提交到git上，然后打上tag，推送到git服务器上。这样是为了让repo仓库在检索的时候能够找到组件库所在的位置。 1234567891011121314151617181920$ pod repo push LeRepo XXXLibProject.podspecValidating spec -&gt; XXXLibProject (0.1.0)Updating the `LeRepo' repoYour configuration specifies to merge with the ref 'master'from the remote, but no such ref was fetched.Adding the spec to the `LeRepo' repo - [Add] XXXLibProject (0.1.0)Pushing the `LeRepo' repoUsername for 'https://gitlab.xxx.com': agenricPassword for 'https://gitlab.xxx.com':To https://gitlab.xxx.com/agenric/LeRepo.git * [new branch] master -&gt; master 完成之后这个组件库就添加到了我们私有的repo库（LeRepo）中了，可以进入到~/.cocoapods/repos/LeRepo 目录下进行查看。 到此之后你就可以在你的XXXMainProject中引入这个组件库了，需要注意的是你要在XXXMainProject项目的Podfile文件头部加入以下两行代码，以确保你在执行pod命令时，pod可以检索的你的私有中心库中的组件库。 12source 'https://github.com/CocoaPods/Specs.git'source 'https://gitlab.xxx.com/agenric/LeRepo.git' 注：鉴于隐私性文中的部分内容使用xxx代替，例如gitlab.xxx.com。所以你可能并不能直接拷贝使用，本文旨在描述基于CocoaPods开发的一系列流程。如有问题，欢迎留言探讨。 补充：额外补充一点，这也是我在使用过程中发现的一些小tips。 相对于发布私有的lib来说，发布公开的lib会简单的多，因为不用有那么多的配置，但是需要注册一个trunk，因为我们需要使用trunk来想公共的CocoaPods库来发布我们想要公开的lib。 注册 12$ pod trunk register eloy@email.com 'my name' #注册，会发带验证链接的邮件到邮箱地址，名称无法修改$ pod trunk me #注册完成后，可通过该语句查询注册信息。 发布过程中，podspec验证可能会遇到一些错误1.语法错误： 这种错误一般会给出准确的错误提示，在文件错误的位置下方会有^提示，所以注意中英文的引号之类的问题。 2.依赖错误： 举个例子比如说你的lib库可能依赖一些.a的静态库（比如：WeiboSDK，WeChatSDK）,类似下面这样： 1- ERROR | [iOS] unknown: Encountered an unknown error (The 'Pods-App' target has transitive dependencies that include static binaries: ( /private/var/folders/c1/fkcs97852_5bbsxc7_xj_6lm0000gn/T/CocoaPods/Lint/Pods/WechatOpenSDK/OpenSDK1.7.7/libWeChatSDK.a, and /private/var/folders/c1/fkcs97852_5bbsxc7_xj_6lm0000gn/T/CocoaPods/Lint/Pods/WeiboSDK/libWeiboSDK/libWeiboSDK.a)) during validation. 事实上，这种错误并不影响Pod的使用，但是无法验证通过。这时候你可以通过 –use-libraries 来让验证通过。 pod spec lint xxx.podspec --verbose --use-libraries 有时你即使使用了 –use-libraries 来忽略错误，也不见得会验证通过，因为这样的话有可能会带来一些警告，这时你可以使用 –allow-warnings 来允许忽略警告。 pod spec lint xxx.podspec --verbose --use-libraries --allow-warnings 如果你使用了这种方式验证通过，那么当你发布的时候，你需要加上同样的参数来保证发布成功。 to be continue…","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://blog.agenric.cn/tags/CocoaPods/"}]},{"title":"一张图看懂 Assets 中图片的 Slicing","slug":"One-picture-to-understand-Assets-Slicing-of-pictures","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2016/12/19/One-picture-to-understand-Assets-Slicing-of-pictures/","link":"","permalink":"http://blog.agenric.cn/2016/12/19/One-picture-to-understand-Assets-Slicing-of-pictures/","excerpt":"","text":"我使用ps自己画了一张图片如下图：这是一张2倍像素的图片，我把它拖入Assets.xcassets中。选择右下角Slices的类型为Horizontal and Vertical：左侧ShowSlicing显示如下：在storyboard拖入一个ImageView，上下左右距离边框均为20。则显示如下： 简单来记就是纵横各三条线，线之外的四个角不会拉伸。六条线内部交汇处，亮色区域为拉伸区域，灰色蒙版区域被截取掉，不显示。仅此而已。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"iOS小知识","slug":"iOS小知识","permalink":"http://blog.agenric.cn/tags/iOS小知识/"},{"name":"Xcode","slug":"Xcode","permalink":"http://blog.agenric.cn/tags/Xcode/"}]},{"title":"iOS 客户端节日换肤的思考与实现","slug":"iOS-APP-change-theme","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2016/12/13/iOS-APP-change-theme/","link":"","permalink":"http://blog.agenric.cn/2016/12/13/iOS-APP-change-theme/","excerpt":"","text":"最近单位的APP来了新的需求，市场说他们要在圣诞节把APP里的图标都换了，还要换背景图片，还要给部分view添加一个遮盖。对，就是换肤。以前没有搞过换肤，所以考虑了一天，感觉大概就是这么个思路，感觉有问题的大家可以一块讨论。 总体来说主要分为两个部分： 第一部分主要是服务器资源的远程加载 第二部分主要就是图片资源的加载了 服务器资源的远程加载先说一下我们的要求是，一般在活动的前一天或前几天会提前把资源准备好放在服务器，然后后台开启换肤的接口，也就是说争取在活动开始前确保大多数用户已经把节日需要的资源下载到了本地，然后服务器接口返回会有此次活动的开始时间以及结束时间。然后在活动期间用户打开APP的话动态更换资源。暂时不考虑极限情况，例如用户在活动开始之前始终没有打开过APP，那么该用户当天打开APP第一次是不会看到最新的皮肤。流程图是刚开始考虑的时候按着当时的思路画的，具体实现的时候有些许偏差，不过总起来说就是这个逻辑。在APP初次打开时配置关于皮肤的一些参数信息比如说我们默认把起始时间都定为1970年1月1日，把活动id定为0，以后递增反正自我发挥，只要能确保与之后服务器的数据做对比，之后再次打开时只是去读取之前存好的值，在这里我会有一个换肤服务的一个单例，提供一个只读属性来标示现在是否需要更换资源。 123456789@interface ChangeSkinService : NSObject// 是否允许更换资源@property (nonatomic, assign, readonly, getter=isShouldChangeSkin) BOOL shouldChangeSkin;+ (instancetype)sharedInstance;- (void)configService;- (NSString *)resourceFile;@end 如果服务器的版本高于本地的版本，则证明可能有换肤活动，这时需要判断服务器活动的结束时间，如果这个时间早于当前时间说明这次活动可能已经过期，那么客户端也就没有下载资源的必要了。如果这个时间晚于当前时间，则需要下载资源，这里可以给一个资源状态的标示，用来以防本地的版本已经跟服务器的同步而资源并没有下载成功的意外情况。事实上，我们可以一直等到资源下载并解压完成后再更改本地的所有设置，中间如果发生不可预料的错误，也可以避免客户端本地产生脏数据。 图片资源的加载这部分基本上没什么操作难点，无非就是运行时更改+ (nullable UIImage *)imageNamed:(NSString *)name;方法，重写该方法，在ChangeSkinService单例允许更换资源的情况下，去本地沙盒的Document文件夹中读取需要的图片。具体细节可以根据各自业务的不太来制定，大致思路是不变的，比如说你客户端有的地方的图片可能会有拉伸之类的需求，但这样其实是不影响的，因为图片拉伸的操作底层依然需要调用imageNamed:方法来找到该图片。所以，基本也就这样。如果你有问题也可以留言我们一起讨论。 注：此文章首发在简书转载请说明出处。如果你想看到完整的代码，可以去这里。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"iOS小知识","slug":"iOS小知识","permalink":"http://blog.agenric.cn/tags/iOS小知识/"}]},{"title":"自定义地区联动选择器","slug":"Custom-Area-Linkage-Picker","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2016/04/02/Custom-Area-Linkage-Picker/","link":"","permalink":"http://blog.agenric.cn/2016/04/02/Custom-Area-Linkage-Picker/","excerpt":"","text":"前两天收到一个朋友的飞鸽求助，其实也说不上是求助了，就是朋友之间的友好交流。 传来一个文件，名称area.plist。打开看了之后我就懂了，事实上我感觉这玩意网上应该多了去了，但是，自己写一下应该也蛮有意思。 OK，先来看一下数据结构，因为我最开始就是因为没有充分研读数据文件，造成中间绊了很多没必要的坎。 这样解释，一级根字典共包含34个元素（即23个省、4个直辖市、5个自治区、2个特别行政区），其中每个元素又是一个字典，并且是一个有且仅有一个键值对的字典。这唯一的键即是该省的名称。例：上图中第五个元素中，字典的value就是河北省的数据结构。 接下来是二级子元素，二级字典有且仅有一个三级元素，该三级元素为字典类型。 三级元素开始从省份下细分市级元素，每个市级元素还是一个字典，并且依然是一个有且仅有一个键值对的字典。这唯一的键即是该市的名称。例：上图中河北省下共设11个市，这11个子元素中，每个value就代表一个市的数据结构。 接下来是第四级元素，四级元素有且仅有一个五级元素，该五级元素为数组类型。 五级元素开始从市下细分区、县级元素，每个区、县级元素就是数组中的一个简单的字符串元素，该字符串即是该区、县的名称。例：上图中河北省石家庄市共设23个区、县。 此处应该有个黑线脸…… 不知道你们看的拗不拗眼，反正我说的是挺拗口的。对，刚开始我不太理解为什么会是这么复杂的结构，比如说国家下一级为什么不直接用省的名字作为key来存储，而非要再给每个省都额外再包装一个字典，省元素的下一级为什么不直接用市的名字为key来存储，而非要给每个市都再额外包装一个字典。就像下面这样： 12345678910111213141516171819202122&#123; \"北京市\":&#123; \"北京市\":[ \"东城区\", \"西城区\", \"朝阳区\", ... ] &#125;, \"河北省\":&#123; \"石家庄市\":[ \"长安区\", \"桥东区\", \"桥西区\", ... ], \"唐山市\":[ ... ], &#125;, ...&#125; 难道不好么… 呵呵呵，如果你跟我一样这样想，那我告诉你：Too Young Too Simple。 因为是这样，Foundation框架中的NSDictionary。它有一个只读属性allKeys。如果按照我们以上这个字典的设计形式，我想要通过allKeys获取全国所有的省份，拿到结果后你会发现，Oh NO。这顺序，不忍直视对吗，并且每次调用这个方法的返回顺序可能都不尽相同，这就是iOS中字典这个数据结构的特性，他并没有对自己的元素进行有效的排序，不像数组那样，第一个add进去的就肯定是数组的第0号元素。 所以现在我们明白，为什么每个子列表下的元素都要通过外边再包一层index的手段来确保能够手动的实现子列表下元素的有序排列。 然后，接下来Coding： 首先，自定义的PickerView实现UIPickerViewDataSource、UIPickerViewDelegate。 DataSource需要返回该picker共有几个组，每个分组下有多少行。 123456789101112131415161718192021- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component &#123; if (component == 0) &#123; // 第一组 return [self.totalDatas count]; &#125; else if (component == 1) &#123; // 第二组 // 省级父类的字典 NSDictionary *provinceFather = [self.totalDatas valueForKey:[NSString stringWithFormat:@\"%ld\",(long)[pickerView selectedRowInComponent:0]]]; // 省字典 NSDictionary *provinceDictionary = [provinceFather valueForKey:[[provinceFather allKeys] firstObject]]; return [provinceDictionary count]; &#125; else &#123; // 第三组 // 省级父类的字典 NSDictionary *provinceFather = [self.totalDatas valueForKey:[NSString stringWithFormat:@\"%ld\",(long)[pickerView selectedRowInComponent:0]]]; // 省字典 NSDictionary *provinceDictionary = [provinceFather valueForKey:[[provinceFather allKeys] firstObject]]; // 市字典 NSDictionary *cityDictionary = [provinceDictionary valueForKey:[NSString stringWithFormat:@\"%ld\",(long)[pickerView selectedRowInComponent:1]]]; // 区数组 NSArray *districtArray = [cityDictionary valueForKey:[[cityDictionary allKeys] firstObject]]; return [districtArray count]; &#125;&#125; Delegate一共提供了三种方法供我们自定义每一个item的显示。分别是返回一个NSString、NSAttributedString、UIView。因为地区的选择无非就是固定item返回对应的字符串，但是有个问题就是要考虑字体的显示是否可以显示完整之类的，所以我们最好选择返回NSAttributedString或自定义UIView这种方式，可定制化更高。这里我选择了使用UIView（UILabel）： 1234567891011121314151617181920212223242526272829- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(nullable UIView *)view &#123; UILabel *desLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH / 3.0f, 30)]; [desLabel setBackgroundColor:[UIColor clearColor]]; [desLabel setTextAlignment:NSTextAlignmentCenter]; [desLabel setFont:[UIFont systemFontOfSize:14]]; // 省级父类的字典 NSDictionary *provinceFather = [self.totalDatas valueForKey:[NSString stringWithFormat:@\"%ld\",(long)[pickerView selectedRowInComponent:0]]]; // 省字典 NSDictionary *provinceDictionary = [provinceFather valueForKey:[[provinceFather allKeys] firstObject]]; // 市字典 NSDictionary *cityDictionary = [provinceDictionary valueForKey:[NSString stringWithFormat:@\"%ld\",(long)[pickerView selectedRowInComponent:1]]]; // 区数组 NSArray *districtArray = [cityDictionary valueForKey:[[cityDictionary allKeys] firstObject]]; if (component == 0) &#123; // 第一组 [desLabel setText:[[[self.totalDatas valueForKey:[NSString stringWithFormat:@\"%ld\", (long)row]] allKeys] firstObject]]; return desLabel; &#125; else if (component == 1) &#123; // 第二组 [desLabel setText:[[[provinceDictionary valueForKey:[NSString stringWithFormat:@\"%ld\", (long)row]] allKeys] firstObject]]; return desLabel; &#125; else &#123; // 第三组 if (districtArray.count &lt;= row) &#123; return nil; &#125; [desLabel setText:districtArray[row]]; return desLabel; &#125;&#125; 以上self.totalDatas即是地区plist文件读取出来的字典。 需要注意的就是： 首先：一定要理清这个字典内部详细的数据结果，这样我们才能清晰的知道，什么时候需要使用allKeys，什么时候需要firstObject，什么时候需要valueForKey。 其次：要实现Delegate中的-(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component方法，确保在每一个单元格的值改变后更新它的联动数据，如果省份数据发生变化需要更新市的数据和区、县的数据，如果市的数据发生了变化则只需要更新区、县的数据。 最后：在用户选择完成后，我们可以选择代理或者block的方式将结果传递回去。这里根据当前picker每一列的行数，获取该行对应的名称即可。同样还是，注意数据结构，要明白我们每一步的操作取出的到底是字典数据还是数组数据，这至关重要，代码在下面： 123456789101112131415161718192021/* 省 */NSInteger provinceIndex = [self.myPickerView selectedRowInComponent:0];/* 市 */NSInteger cityIndex = [self.myPickerView selectedRowInComponent:1];/* 区 */NSInteger districtIndex = [self.myPickerView selectedRowInComponent:2];// 省级父类的字典NSDictionary *provinceFather = [self.totalDatas valueForKey:[NSString stringWithFormat:@\"%ld\",(long)provinceIndex]];// 省的名字NSString *selectedProvinceName = [[provinceFather allKeys] firstObject];// 省字典NSDictionary *provinceDictionary = [provinceFather valueForKey:selectedProvinceName];// 市字典NSDictionary *cityDictionary = [provinceDictionary valueForKey:[NSString stringWithFormat:@\"%ld\",(long)cityIndex]];// 市的名字NSString *selectedCityName = [[cityDictionary allKeys] firstObject];// 区数组NSArray *districtArray = [cityDictionary valueForKey:selectedCityName];// 区名字NSString *selectedDistrictName = districtArray[districtIndex]; 瑕疵看图就懂： 我们会发现，有些地方的名字为啥辣么长… 我在想他们参加工作入职填表的时候，家庭住址那一栏，要折几行才能写完。哈哈哈…玩笑了，证明除了逻辑整明白之后，一定要充分考虑UI显示，比如说到底是用NSAttributedString还是自定义UIView，每个item的宽度如何分配，不过这些东西我们就不在这里赘述了… 最后，还有一点，当我写完文章的时候我忽然又想起这个数据结构，为什么我们一开始不直接从这个数据结构来入手呢？比如说，这样： 123456789101112[ &#123; \"北京\":[ &#123;\"北京市\":[\"朝阳区\",\"东城区\",\"海淀区\"]&#125; ]&#125;, &#123; \"河南省\":[ &#123;\"郑州市\":[\"中原区\",\"二七区\",\"金水区\"]&#125;, &#123;\"洛阳市\":[\"老城区\",\"西工区\"]&#125;, &#123;\"许昌市\":[\"魏都区\",\"许昌县\",\"鄢陵县\"]&#125; ]&#125;,] 会不会就解决了我们之前每个字典都要再包一层index的问题呢，留给各位一试。 如果你想看一下代码，去这里。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"iOS小知识","slug":"iOS小知识","permalink":"http://blog.agenric.cn/tags/iOS小知识/"}]},{"title":"网易新闻系列-自定义底部 Dock 栏目选择器","slug":"Imitate-netease-custom-dock","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2015/11/22/Imitate-netease-custom-dock/","link":"","permalink":"http://blog.agenric.cn/2015/11/22/Imitate-netease-custom-dock/","excerpt":"","text":"作为系列第一篇文章，就先从最简单的底部的这个Dock栏开始。 示例展示其实说是最简单的，也是应用最广泛的。我们应该看过很多APP的导航界面的样式。基本上就以下两种： 系统原生的UITabBar始终在页面底部，并不跟随界面跳转而隐藏和显示 网易新闻类似的底部TabBar只在每个栏目的首页显示，在第二级或第三级页面隐藏（ps:请自动忽略新闻内容） 自定义底部Item既然是自定义控件，就要尽量做到低耦合，高内聚。也就是说外部不用知道内部的具体实现原理，只用公开出一个接口供使用方调用即可。在这里，外部告诉我要添加一个新的item，同时告诉我这个item的普通图片、选中图片以及显示文字。Dock内部会根据当前添加的item数量规范的调整显示每一个item的位置及状态。在Dock.h文件中我有一个这个方法:- (void)addItemWithIcon:(NSString *)icon selectedIcon:(NSString *)selectedIcon title:(NSString *)title;内部实现为： 12345678910111213141516171819202122232425- (void)addItemWithIcon:(NSString *)icon selectedIcon:(NSString *)selectedIcon title:(NSString *)title &#123; DockItem *dockItem = [[DockItem alloc]init]; [dockItem setImage:[UIImage imageNamed:icon] forState:UIControlStateNormal]; [dockItem setImage:[UIImage imageNamed:selectedIcon] forState:UIControlStateSelected]; [dockItem setTitle:title forState:UIControlStateNormal]; // 这里你也可以把正常状态和选中状态下的字体颜色开放出去在外部设置 [dockItem setTitleColor:[UIColor colorWithRed:137/255.0f green:137/255.0f blue:137/255.0f alpha:1] forState:UIControlStateNormal]; [dockItem setTitleColor:[UIColor colorWithRed:223/255.0f green:41/255.0f blue:43/255.0f alpha:1] forState:UIControlStateSelected]; [dockItem addTarget:self action:@selector(itemClick:) forControlEvents:UIControlEventTouchDown]; [self addSubview:dockItem]; int count = (int)self.subviews.count; // Dock默认显示第一项 if (count == 1) &#123; [self itemClick:dockItem]; &#125; CGFloat width = self.frame.size.width / count; CGFloat height = self.frame.size.height; for (int i = 0; i &lt; count; i++) &#123; DockItem *item = self.subviews[i]; item.tag = i; item.frame = CGRectMake(width * i, 0, width, height) &#125;&#125; 在每一次添加新的item的同时，其内部自动的重新去设置每个item的位置以达到友好的显示。其次，我们知道每一个item实是上是一个UIButton，所以要做到这个Button的显示跟系统的不一样，我重写了UIButton的两个方法以达到图片与文字上下显示的效果，给定一个图片与文字的高度的比例，我这里设置的kImageRatio = 0.7，代码如下： 12345678910111213141516171819#pragma mark 调整内部ImageView的frame- (CGRect)imageRectForContentRect:(CGRect)contentRect&#123; CGFloat imageX = 0; CGFloat imageY = 0; CGFloat imageWidth = self.frame.size.width; CGFloat imageHeight = self.frame.size.height * kImageRatio; return CGRectMake(imageX, imageY, imageWidth, imageHeight);&#125;#pragma mark 调整内部UILable的frame- (CGRect)titleRectForContentRect:(CGRect)contentRect&#123; CGFloat titleWidth = self.frame.size.width; CGFloat titleHeight = self.frame.size.height * (1 - kImageRatio); CGFloat titleX = 0; CGFloat titleY = self.imageView.frame.size.height - 3; return CGRectMake(titleX, titleY, titleWidth, titleHeight);&#125; 至此，比如说我现在要给Dock栏添加一个新闻item，并把这个item需要的两张图片传进去，那么我只需要执行[self.dock addItemWithIcon:@&quot;tabbar_icon_news_normal&quot; selectedIcon:@&quot;tabbar_icon_news_highlight&quot; title:@&quot;新闻&quot;];就可以了。 监听Item点击接着我们就来介绍如何做到让底部的这个Dock栏随着控制器的切换而做到自动的跟随每一个需要它跟随的控制器。在日常的开发中，相信大家基本上每个人都做过顶部标题下部菜单类似的APP。并且我相信更多的是第二种的显示方式，细心的人会发现这个Dock栏始终都会跟随每个栏目的第一个控制器，那么我们是不是可以这样考虑，假设说每一个栏目都是一个导航控制器，那么这个导航控制器下可能会push出N多个子控制器，但是这个导航控制器有且只会有一个根(root)控制器，也就是说我们的Dock栏只需要跟随这个导航控制器的根控制器即可。SO…在这里边其实要处理的无非就是底部Dock这个View。 那么先说一下我的思路： 整个APP一般可能会有3-5个一级的界面，那么先搞一个MainController来管理这么多子页面 一般情况下每个一级的界面都会有2-3个子页面，可见每个子页面都是有一个导航控制器包着的页面 我们要实现的功能就是在每个导航控制器的根控制器显示在最前的时候，显示底部Dock栏，那么如果当前显示在最前的控制器不是导航控制器的根控制器时，就要隐藏Dock栏 这样就很容易想到UINavigationController的代理方法，我们让MainController成为它的每一个子页面的导航控制器的代理，然后统一在代理方法里去做处理 我先在MainController里添加了五个子控制器 123456789101112131415161718192021222324252627282930#pragma mark - Private Methods- (void)addChildViewControllers &#123; UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:FirstViewController.new]; nav.delegate = self; [self addChildViewController:nav]; UIViewController *vc = [[UIViewController alloc] init]; nav = [[UINavigationController alloc] initWithRootViewController:vc]; vc.view.backgroundColor = [UIColor redColor]; nav.delegate = self; [self addChildViewController:nav]; vc = [[UIViewController alloc] init]; nav = [[UINavigationController alloc] initWithRootViewController:vc]; vc.view.backgroundColor = [UIColor orangeColor]; nav.delegate = self; [self addChildViewController:nav]; vc = [[UIViewController alloc] init]; nav = [[UINavigationController alloc] initWithRootViewController:vc]; vc.view.backgroundColor = [UIColor blueColor]; nav.delegate = self; [self addChildViewController:nav]; vc = [[UIViewController alloc] init]; nav = [[UINavigationController alloc] initWithRootViewController:vc]; vc.view.backgroundColor = [UIColor grayColor]; nav.delegate = self; [self addChildViewController:nav];&#125; 处理点击，更新显示既然是MainController来管理所有的子栏目，那么很显然Dock应该属于MainController的View的子view。也就是说实事上在MainController上显示的每一个子导航控制器的frame的size的height并不是填充了整个屏幕。那么既然Dock栏并不属于某一个子栏目，我们要怎样使它随着任何一个导航控制器的根控制器来回移动呢，一个处理方法就是：当我们在UINavigationController的代理方法中来做处理。因为当前主控制器(Maincontroller)是所有子栏目导航控制器的代理，这样无论哪一个栏目中的控制器被点击，MainController都能及时的做出处理。既然我们已经知道当前页面中的逻辑关系，那么接下来要做的就是监听每一次将要push或pop新控制器时，判断当前控制器是不是根控制器。假如现在要展示一个新的控制器，如果它不是根控制器那么就要拉长当前导航控制器的height，并且此时将Dock从main上边移除，将其添加到root控制器上，这样在某一个导航控制器push出一个新的子页面时，Dock就会跟随root控制器一起被隐藏；同样如果它是根控制器那么就要把拉长的导航控制器的height变回初始高度，并且把Dock从根控制器上重新移回到main上。这里要注意的一点就是，一个操作是在新控制器将要展示之前就要做，另一个是在新控制器展示出来之后再做。至于哪一个是will哪一个是did，大家可以自己考虑一下，如果你真的不太理解可以去看一下这个项目demo的源码(地址在下面会给出)。 Dock栏的移动与隐藏基本上就这样，那么Dock栏既然充当的是一个UITabBar的作用，也就是说我们在选择某一个栏目的同时MainController应该及时的隐藏旧的栏目并显示新的栏目，然而这并不难办，使用代理很简单的就能实现这个功能，在Dock上的item接收到点击事件时改变自身显示的同时告诉自己的代理你现在要给我显示第几个子控制器就行了。至于代码我就不再在这贴了。最后，我又给这个Dock添加了一个新的小功能，大家在上图应该也能看到第三个和第四个item右上角的一个mark小红点。提示用户某一个栏目中可能有新消息或是活动，添加新消息提示的mark点共有两种模式，一种是只显示有新消息标示而不显示具体数目，另一种是直接显示新消息的条数，那么具体使用哪种模式就看个人爱好了。 注：此文章首发在简书转载请说明出处。如果你想看到完整的代码，可以去这里。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"网易新闻","slug":"网易新闻","permalink":"http://blog.agenric.cn/tags/网易新闻/"}]},{"title":"模仿新浪微博个人中心界面导航栏渐隐渐现效果","slug":"Imitate-sinaWeibo-pull-refresh","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2015/10/11/Imitate-sinaWeibo-pull-refresh/","link":"","permalink":"http://blog.agenric.cn/2015/10/11/Imitate-sinaWeibo-pull-refresh/","excerpt":"","text":"这两天又看了一个新浪微博个人中心界面的一个小功能。 事实上在这大约一年之前，我已经做过类似的Demo。那个时候我应该还在为自己的毕业设计而忙活，当时做这个效果的时候我用了一个可能所有的初学者都会想到的一个方法，那就是给tableView分组。首先把上边头像后边高度为200px的背景作为一组，然后把下边的选项卡与微博作为另外一组。这样的结果就是，我要去判断当前是第0组还是第一组，以此来返回对应的section的header。 但是这次我运用的方法就显得不那么… 毕竟每个人都要不断学习，不断提高自己。期初这个方法也是我在看啊崢的文章中看到的。但是我一直认为，不管是自己研究出来的，还是从别的地方看来的，能够消化吸收变成自己的才是真理。 我们先来看一下实现以后的效果：其实，实现的思想也就以下两点： 导航栏，导航栏的透明度其实是随着scrollView向上的滚动而变的，所以说他们肯定是存在一定的联系。 选项卡，底部所有微博列表上方的选项卡随着tableView的向上的滚动最终会卡在导航栏下方不动，类似于tableView中section的header。但事实上在这里我们根本不用这样做，我们只需要让这个选项卡的顶部始终黏贴在他上方的头像背景图的底部，而后设置头像背景图的最小高度不小于64(即导航栏的高度)即可。 搭建界面从层次划分上看出来类似tableView的header以及tab在self.view上的添加顺序是在mainTableView之后的，这样就能在我们调整tableView的contentInset时候，让他们盖在tableView上方。需要注意的是用户头像是在header这个view中的这样才能保证tableView在上下滚动的时候头像始终都保持在header的中心位置。 设置初始界面在viewDidLoad中，我们要修改当前页面的初始状态，包括tableView的偏移位置，顶部导航栏的透明状态，以及导航栏标题。 123456789101112131415161718192021#pragma mark - setupUI- (void)setupUI &#123; // tableView _defaultOffsetY = -(kTableViewHeaderDefH + kTableViewTabH); [self.mainTableView setContentInset:UIEdgeInsetsMake(-_defaultOffsetY, 0, 0, 0)]; self.automaticallyAdjustsScrollViewInsets = NO; [self.mainTableView setTableFooterView:[[UIView alloc] init]]; // navigationBar [self.navigationController.navigationBar setBackgroundImage:[[UIImage alloc] init] forBarMetrics:UIBarMetricsDefault]; [self.navigationController.navigationBar setShadowImage:[[UIImage alloc] init]]; // title UILabel *titleLabel = [[UILabel alloc] init]; titleLabel.text = @\"Agenric\"; [titleLabel sizeToFit]; self.navigationItem.titleView = titleLabel; _titleLabel = titleLabel; _titleLabel.alpha = 0; _titleLabel.hidden = YES;&#125; 监听tableView的滚动 我们事先给header的view一个NSLayoutConstraint类型的属性，同时我们需要定义关于header的两个宏 12#define kTableViewHeaderDefH 200#define kTableViewHeaderMinH 64 1@property (weak, nonatomic) IBOutlet NSLayoutConstraint *tableViewHeaderH; header的高度要同时满足以下两个条件。根据用户滚动的偏移量来计算tableViewHeaderH.constant的值，我们知道tableView的contentOffset.y初始值是与header和tab的高度和，也就是说他们之间需要满足这样的关系 12tableViewHeaderH.constant = kTableViewHeaderDefH - (tableView. contentOffset.y - (header.height + tab.height))tableViewHeaderH.constant &gt;= kTableViewHeaderMinH 需要注意的是为什么我们要设置一个kTableViewHeaderMinH呢，因为在滚动tableView的时候，我们要保证在其向上滚动时，选项卡最后是要停留在导航栏下边类似tableView的section的header的状态，但其实，事实上我们只是做了一个假的section的header，它的顶部是粘在头像背后的那个高度为200px的header底部的，也就是说如果这个header的高度如果变为0的话选项卡就会被导航栏完全掩盖掉，这显然不是我们要的结果，这也是为什么上一步中我说header要满足的条件的第二条的原因。 最后还要处理的就是导航栏的标题Label，在viewDidLoad中我们把导航栏中的标题Label的透明度设为了0，以及hidden属性设置成了YES。这样我们在计算当前导航栏的透明度时一旦透明度大于0时，就要开始显示这个Label，并且实时修改其透明度，反之就要继续隐藏这个Label。 至此，这个小功能就被我们实现了。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"iOS小知识","slug":"iOS小知识","permalink":"http://blog.agenric.cn/tags/iOS小知识/"}]},{"title":"模仿 iOS 8.0 邮件左划删除的功能","slug":"Imitate-iOS-email-left-slide-to-delete","date":"un44fin44","updated":"un11fin11","comments":true,"path":"2015/10/08/Imitate-iOS-email-left-slide-to-delete/","link":"","permalink":"http://blog.agenric.cn/2015/10/08/Imitate-iOS-email-left-slide-to-delete/","excerpt":"","text":"最近自己看了一下iOS 8.0中的邮件删除的功能，在iOS8.0中苹果给tableView新增了一个在Cell上侧滑，右边弹出按钮进行便捷操作的一个新的代理方法。但是细心的话你会发现，这个方法只提供类似QQ、微信中的那种单调的弹出菜单，并不能实现类似邮件中的从右一直往左拉到一定程度可以直接删除的快捷操作。所以自己就想试着写一个这样的小Demo，如果你不经意间看到了，欢迎指证，不喜勿喷… 其实仔细的思考一下这个东西，并不是太有技术含量（ps:好吧， 承认自己程度没那么高，所以也想通过这种方式提高自己）。我大概的把要做的工作分了以下几步： 首先自定义自己的Cell，Cell要提供两个代理方法 获取每一行Cell右边将要显示的按钮集合 每一行Cell右边按钮被点击后的回调 其次就是在Cell内部要实现touchesBegan等一系列方法来监测我们的拖拽手势 在touchesMoved里面根据用户拖拽手势的点来动态改变Cell中contentView和右边按钮的frame 定义自己的Cell下面我们首先创建自定义的一个Cell 12345678910111213141516171819202122232425262728293031323334353637383940414243#import &lt;UIKit/UIKit.h&gt;#import \"AGTableViewRowAction.h\"@protocol AGTableViewCellDelegate &lt;NSObject&gt;@optional/*! * @brief 获取每一行Cell对应的按钮集合 * * @param tableView 父级tableView * @param indexPath 索引 * * @return 该行Cell的按钮集合 */- (NSArray *)AGTableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath;/*! * @brief 每一行Cell的动作触发回调 * * @param tableView 父级tableView * @param index 点击按钮集合的动作索引 * @param indexPath 索引 */- (void)AGTableView:(UITableView *)tableView didSelectActionIndex:(NSInteger)index forRowAtIndexPath:(NSIndexPath *)indexPath;@end@interface AGTableViewCell : UITableViewCell/*! * @brief 滑动过程中刷新动画的时间间隔，默认值是0.2s */@property (nonatomic, assign) CGFloat dragAnimationDuration;/*! * @brief 重置动画的时长，默认值是0.3s */@property (nonatomic, assign) CGFloat resetAnimationDuration;@property (nonatomic, assign) BOOL isEditing;@property (nonatomic, weak) id&lt;AGTableViewCellDelegate&gt; delegate;-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier inTableView:(UITableView *)tableView;@end 这个类的实例化方法除了接收tableView的Cell的样式以及复用标示之外，还把其所属的tableView作为气的一个属性传过来，目的是为了在用户拖动Cell的时候限制tableView的滚动。 头文件中的两个设置动画时长的属性以及Cell的预设值需要在初始化方法中进行如下设置 12345678910111213self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];if (self) &#123; [self.contentView setBackgroundColor:[UIColor grayColor]]; self.tableView = tableView; self.touchBeganPointX = 0.0f; self.dragAnimationDuration = 0.2f; self.resetAnimationDuration = 0.3f; self.isEditing = NO; _isMoving = NO; _hasMoved = NO;&#125;return self; 这里我使用了两个临时的局部变量_isMoving _hasMoved来在Cell被拖动的时候标示其状态，使用self.isEditing来判断在当前Cell上是应该响应一般touch事件还是响应它的tableView的didSelectRowAtIndexPath事件。然后我们要在Cell内部拥有一个可变的数组来存储该行Cell右边的action集合，然后最好在layoutSubviews的时候通过代理方法拿到这个集合。 1234567891011121314- (void)getActionsArray &#123; self.indexPath = [self.tableView indexPathForCell:self]; if ([self.delegate respondsToSelector:@selector(AGTableView:editActionsForRowAtIndexPath:)]) &#123; self.actionButtons = [[self.delegate AGTableView:self.tableView editActionsForRowAtIndexPath:self.indexPath] mutableCopy]; CGFloat buttonWidth = (SCREENWIDTH / 2.0f) / self.actionButtons.count; self.buttonWidth = buttonWidth; for (AGTableViewRowAction *action in self.actionButtons) &#123; action.frame = CGRectMake(SCREENWIDTH, 0.0f, buttonWidth, self.height); [action addTarget:self action:@selector(rightActionDidSelected:) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:action]; &#125; &#125;&#125; 注意最后[self addSubview:action]，通常我们习惯在self.contentView上添加子View，但是记得不要把右边的action添加到contentView上去。这样的话在移动contentView的时候会带着右边的action一同移动。 监听手势这些工作做完接下来就是核心的处理逻辑，监听用户触摸的手势： 首先要touchesBegan方法内判断touches.count是否为1，若不为1则调用父类的方法 [super touchesBegan:touches withEvent:event] ，若为1则记录用户开始接触到屏幕是的点的水平(x)轴的坐标，以备使用。 然后要在touchesMoved方法内针对用户触摸的点与开始触摸屏幕是的点进行对比并对当期Cell的所有子View的frame进行更改。 最后在touchesEnded方法中获取到用户最后触摸的点，然后来判定Cell当前该执行哪一种操作 1. 删除自己 2. 恢复到展示右边actions的状态 3. 恢复到隐藏右边actions的最初始的状态 下面是touchesMoved中动态改变Cell内部子View的一段代码 123456789101112131415161718192021222324252627CGFloat currentLocationX = [touch locationInView:self.tableView].x;CGFloat distance = (self.touchBeganPointX - currentLocationX) * 1.1;if (distance &gt; 0) &#123; // 向左拉 CGFloat button_addWidth = (distance - (SCREENWIDTH / 2.0)) / self.actionButtons.count; [UIView animateWithDuration:self.dragAnimationDuration animations:^&#123; self.contentView.left = -distance; CGFloat t_dis = distance; for (AGTableViewRowAction *action in self.actionButtons) &#123; if (distance &gt; SCREENWIDTH / 2.0f) &#123; if (currentLocationX &lt; 50) &#123; action.left = SCREENWIDTH - distance; action.width = distance; &#125; else &#123; action.left = SCREENWIDTH - t_dis; action.width = self.buttonWidth + button_addWidth; &#125; &#125; else &#123; action.left = SCREENWIDTH - t_dis; &#125; t_dis = t_dis - distance / self.actionButtons.count; &#125; &#125;];&#125; else &#123; // 向右拉 // doSomething&#125; 在这里我把distance作为用户在Cell上拖动的长度，之所以在后边乘以一个1.1，这其实是模拟一个弹性系数，让Cell的移动距离稍稍的大于用户手指拖动的距离，而1.1的系数在真实显示的情况下并不是很明显，你可以适当的修改这个数值达到自己理想的效果，从而获得更好的用户体验度。 我们用beganPointX减去currentPointX这样得到的值若是大于0则证明用户是在向左滑动，这样从开始滑动就要开始设置contentView的origin.x=-distance。然后遍历右边的actions数组，由于右边所有按钮总的初始宽度我预设的是当前屏幕的一把，这样也就是说，当用户滑动的距离超过屏幕宽度一般的时候就要开始修改每一个action的width。 那么在这里我设置的是当用户手指拉倒距离屏幕左边距离小于50，并且总的拖动长度大于屏幕的一半时，瞬间修改最右方的action的origin.x为用户手指当前位置的x轴上的位置，宽度增长到当前拖动的长度，然后当用户手指离开屏幕的时候，根据contentView的origin.x的位置来选择该如何重置或是删除当前Cell。 处理手势最后，关于在touchesEnded中如何做处理，以及其他的一些细节就不在此赘述了。如果你想看到更详细的内容可以去下载该项目的demo源码。 注：此文章首发在简书转载请说明出处。如果你想看到完整的代码，可以去这里。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"}],"tags":[{"name":"iOS小知识","slug":"iOS小知识","permalink":"http://blog.agenric.cn/tags/iOS小知识/"}]}],"categories":[{"name":"效率","slug":"效率","permalink":"http://blog.agenric.cn/categories/效率/"},{"name":"技术","slug":"技术","permalink":"http://blog.agenric.cn/categories/技术/"},{"name":"工具","slug":"工具","permalink":"http://blog.agenric.cn/categories/工具/"}],"tags":[{"name":"Travis CI","slug":"Travis-CI","permalink":"http://blog.agenric.cn/tags/Travis-CI/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.agenric.cn/tags/LeetCode/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog.agenric.cn/tags/Hexo/"},{"name":"Git","slug":"Git","permalink":"http://blog.agenric.cn/tags/Git/"},{"name":"CI","slug":"CI","permalink":"http://blog.agenric.cn/tags/CI/"},{"name":"AV Foundation","slug":"AV-Foundation","permalink":"http://blog.agenric.cn/tags/AV-Foundation/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://blog.agenric.cn/tags/HTTPS/"},{"name":"iOS","slug":"iOS","permalink":"http://blog.agenric.cn/tags/iOS/"},{"name":"iOS小知识","slug":"iOS小知识","permalink":"http://blog.agenric.cn/tags/iOS小知识/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://blog.agenric.cn/tags/CocoaPods/"},{"name":"Xcode","slug":"Xcode","permalink":"http://blog.agenric.cn/tags/Xcode/"},{"name":"网易新闻","slug":"网易新闻","permalink":"http://blog.agenric.cn/tags/网易新闻/"}]}