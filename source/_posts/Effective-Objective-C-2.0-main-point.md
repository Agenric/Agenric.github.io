---
title: Effective Objective-C 2.0 要点摘录
date: 2017-04-18 21:27:03
categories:
 - 技术
tags:
 - iOS
---

1. 了解 Objective-C 语言的起源
   1. Objective-C 为 C 语言添加了面向对象的特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境决定而非编译器决定。
   2. 理解 C 语言的核心概念有助于写好 Objective-C 程序。尤其要掌握内存模型与指针。

2. 在类的头文件中尽量少引入其他头文件
   1. 除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合。
   2. 有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把 “该类遵循某协议” 的这条声明移至 “class-continuation 分类” 中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。

3. 多用字面量语法，少用与之等价的方法
   1. 应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。
   2. 应该通过下标操作来访问数组下标或字典中的键所对应的元素。
   3. 用字面量语法创建数组或字典时，若值中有 nil，则会抛出异常。因此务必确保值里不含 nil。

4. 多用类型常量，少用 #define 预处理指令
   1. 不要使用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此进行查找与替换的操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。
   2. 在实现文件中使用 static const 来定义 “只在编译单元内可见的常量”（translation-unit-specific constant）。由于此类常量不在全局符号表中，所以无须为其名称加前缀。
   3. 在头文件中使用 exten 来声明全局变量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀。

5. 用枚举表示状态、选项、状态码
   1. 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。
   2. 如果把传递给某个方法的选项表示为枚举类型，而多个选项有可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。
   3. 用 NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层的数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。
   4. 在处理枚举类型的 switch 语句中不要实现 default 分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch 语句并未处理所有枚举。

6. 理解 “属性” 这一概念
   1. 具备 readwrite（读写）特质的的属性拥有 “获取方法”（getter）与 “设置方法”（setter）。若该属性由 @synthesize 实现，则编译器会自动生成这两个方法。
   2. 具备 readonly（只读）特质的属性仅用于获取方法，只有当该属性由 @synthesize 实现时，编译器才会为其合成获取方法。你可以用此特质把某个属性对外公开为只读属性，然后在 “class-continuation 分类” 中将其重新定义为读写属性。
   3. assign  “设置方法” 只会执行针对 “纯量类型”（scalar type，例如 CGFloat 或 NSInteger 等）的简单赋值操作。
   4. strong 此特质表明该属性定义了一种 “拥有关系”（owning relationship）。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。
   5. weak 此特质表明该属性定义了一种 “非拥有关系”（nonowning relationship）。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似，然而在属性所指的对象遭到摧毁时，属性值也会清空（nil out）。
   6. unsafe_unretained 此特质的语义和 assign 相同，但是它适用于 “对象类型”（object type），该特质表达一种 “非拥有关系”（“不保留”，unretained），当目标对象遭到摧毁时，属性值不会自动清空（“不安全”，unsafe），这一点与 weak 有区别。
   7. copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其 “拷贝”（copy）。当属性类型为 NSString * 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时候就要拷贝一份 “不可变”（immutable）的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是 “可变的”（mutable），就应该在设置新属性值时拷贝一份。
   8. getter=<name\> 制定 “获取方法” 的方法名。如果某属性时 Boolean 型，而你想为其获取方法上加上 “is” 前缀，那么就可以使用这个办法来指定。比如说，在 UISwitch 类中，表示 “开关”（switch）是否打开的属性值就是这样定义的：

        ```objc
        @property (nonatomic, getter=isOn) BOOL on;
        ```

   9. setter=<name\> 指定 “设置方法” 的方法名。这种用法不太常见。
   10. 可以用 @property 语法来定义对象中所封装的数据。
   11. 通过 “特质” 来指定存储数据所需要的正确语义。
   12. 在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。
   13. 开发 iOS 程序时应该使用 nonatomic 属性，因为 atomic 属性会严重影响性能。

7. 在对象内部尽量直接访问实例变量
   1. 由于不经过 Objective-C 的 “方法派发”（method dispatch）步骤，所以直接访问实例变量的速度当然比较快。在这种情况下，编译器所产生的代码会直接访问保存对象实例变量的那块内存。
   2. 直接访问实例变量时，不会调用其 “设置方法”，这就绕过了为相关属性所定义的 “内存呢管理语义”。比方说，如果在 ARC 下直接访问一个声明为 copy 的属性，那么并不会拷贝该属性，只会保留新值并释放旧值。
   3. 如果直接访问实例变量，那么不会触发 “键值规则”（Key-Value Observing，KVO）通知。这样做是否会产生问题，还取决于具体的对象行为。
   4. 通过属性来访问有助于排查与之相关的错误，因为可以给 “获取方法” 和/或 “设置方法” 中新增 “断点”（breakpoint），监控该属性的调用者及其访问时机。
   5. 在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时则应通过属性来写。
   6. 在初始化方法及 dealloc 方法中，总是应该直接通过实例变量来读写数据。
   7. 有时会使用惰性初始化技术配置某份数据，在这种情况下，需要通过属性来读取数据。

   > 事实上，我个人在开发中并不推崇这种模式。我几乎全部使用惰性初始化技术，通常我会在类的内部使用这种技术重写几乎所有属性的 getter 方法，只在其 getter 方法内部直接使用实例变量，而在之外的所有地方都使用点语法来读写它们。这样无论是从代码风格上、还是美观性、一致性上都相对较好。

8. 理解 “对象等同性” 这一概念
   1. 若要检测对象的等同性，请提供 “isEqual：” 与 hash 方法。
   2. 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。
   3. 不要盲目的逐个检测每条属性，而是应该依照具体需求来制定检测方案。
   4. 编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。